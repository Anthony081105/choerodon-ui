b7a7bee2e59892e542db85eef99dd490
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = rangeOverflow;

var _moment = require("moment");

var _isNil = _interopRequireDefault(require("lodash/isNil"));

var _isEmpty = _interopRequireDefault(require("../../_util/isEmpty"));

var _ValidationResult = _interopRequireDefault(require("../ValidationResult"));

var _localeContext = require("../../locale-context");

var _formatReactTemplate = _interopRequireDefault(require("../../formatter/formatReactTemplate"));

var _utils = require("../../field/utils");

var isOverflow = function isOverflow(value, max, range) {
  if (range) {
    return (0, _utils.toRangeValue)(value, range).some(function (item) {
      return !(0, _isEmpty["default"])(item) && Number(item) > Number(max);
    });
  }

  return !(0, _isEmpty["default"])(value) && Number(value) > Number(max);
};

function rangeOverflow(value, props) {
  var max = props.max,
      label = props.label,
      format = props.format,
      defaultValidationMessages = props.defaultValidationMessages,
      range = props.range;

  if (!(0, _isNil["default"])(max) && isOverflow(value, max, range)) {
    var injectionOptions = {
      max: (0, _moment.isMoment)(max) ? max.format(format) : max,
      label: label
    };
    var ruleName = 'rangeOverflow';
    var _defaultValidationMes = defaultValidationMessages[ruleName],
        validationMessage = _defaultValidationMes === void 0 ? (0, _localeContext.$l)('Validator', 'range_overflow') : _defaultValidationMes;
    return new _ValidationResult["default"]({
      validationMessage: (0, _formatReactTemplate["default"])(validationMessage, injectionOptions),
      injectionOptions: injectionOptions,
      value: value,
      ruleName: ruleName
    });
  }

  return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9odWlodWF3ay9Eb2N1bWVudHMvb3B0L2Nob2Vyb2Rvbi11aS9jb21wb25lbnRzLXByby92YWxpZGF0b3IvcnVsZXMvcmFuZ2VPdmVyZmxvdy50c3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUEsSUFBTSxVQUFVLEdBQUcsU0FBYixVQUFhLENBQUMsS0FBRCxFQUFRLEdBQVIsRUFBYSxLQUFiLEVBQXNCO0FBQ3ZDLE1BQUksS0FBSixFQUFXO0FBQ1QsV0FBTyx5QkFBYSxLQUFiLEVBQW9CLEtBQXBCLEVBQTJCLElBQTNCLENBQWdDLFVBQUEsSUFBSTtBQUFBLGFBQUksQ0FBQyx5QkFBUSxJQUFSLENBQUQsSUFBa0IsTUFBTSxDQUFDLElBQUQsQ0FBTixHQUFlLE1BQU0sQ0FBQyxHQUFELENBQTNDO0FBQUEsS0FBcEMsQ0FBUDtBQUNEOztBQUNELFNBQU8sQ0FBQyx5QkFBUSxLQUFSLENBQUQsSUFBbUIsTUFBTSxDQUFDLEtBQUQsQ0FBTixHQUFnQixNQUFNLENBQUMsR0FBRCxDQUFoRDtBQUNELENBTEQ7O0FBT2MsU0FBVSxhQUFWLENBQXdCLEtBQXhCLEVBQW9DLEtBQXBDLEVBQXlEO0FBQUEsTUFDN0QsR0FENkQsR0FDSixLQURJLENBQzdELEdBRDZEO0FBQUEsTUFDeEQsS0FEd0QsR0FDSixLQURJLENBQ3hELEtBRHdEO0FBQUEsTUFDakQsTUFEaUQsR0FDSixLQURJLENBQ2pELE1BRGlEO0FBQUEsTUFDekMseUJBRHlDLEdBQ0osS0FESSxDQUN6Qyx5QkFEeUM7QUFBQSxNQUNkLEtBRGMsR0FDSixLQURJLENBQ2QsS0FEYzs7QUFFckUsTUFBSSxDQUFDLHVCQUFNLEdBQU4sQ0FBRCxJQUFlLFVBQVUsQ0FBQyxLQUFELEVBQVEsR0FBUixFQUFhLEtBQWIsQ0FBN0IsRUFBa0Q7QUFDaEQsUUFBTSxnQkFBZ0IsR0FBRztBQUFFLE1BQUEsR0FBRyxFQUFFLHNCQUFTLEdBQVQsSUFBZ0IsR0FBRyxDQUFDLE1BQUosQ0FBVyxNQUFYLENBQWhCLEdBQXFDLEdBQTVDO0FBQWlELE1BQUEsS0FBSyxFQUFMO0FBQWpELEtBQXpCO0FBQ0EsUUFBTSxRQUFRLEdBQUcsZUFBakI7QUFGZ0QsZ0NBSzVDLHlCQUw0QyxDQUk3QyxRQUo2QztBQUFBLFFBSWxDLGlCQUprQyxzQ0FJZCx1QkFBRyxXQUFILEVBQWdCLGdCQUFoQixDQUpjO0FBTWhELFdBQU8sSUFBSSw0QkFBSixDQUFxQjtBQUMxQixNQUFBLGlCQUFpQixFQUFFLHFDQUFvQixpQkFBcEIsRUFBdUMsZ0JBQXZDLENBRE87QUFFMUIsTUFBQSxnQkFBZ0IsRUFBaEIsZ0JBRjBCO0FBRzFCLE1BQUEsS0FBSyxFQUFMLEtBSDBCO0FBSTFCLE1BQUEsUUFBUSxFQUFSO0FBSjBCLEtBQXJCLENBQVA7QUFNRDs7QUFDRCxTQUFPLElBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCBpc05pbCBmcm9tICdsb2Rhc2gvaXNOaWwnO1xuaW1wb3J0IGlzRW1wdHkgZnJvbSAnLi4vLi4vX3V0aWwvaXNFbXB0eSc7XG5pbXBvcnQgVmFsaWRhdGlvblJlc3VsdCBmcm9tICcuLi9WYWxpZGF0aW9uUmVzdWx0JztcbmltcG9ydCB7ICRsIH0gZnJvbSAnLi4vLi4vbG9jYWxlLWNvbnRleHQnO1xuaW1wb3J0IHsgbWV0aG9kUmV0dXJuLCBWYWxpZGF0b3JQcm9wcyB9IGZyb20gJy4nO1xuaW1wb3J0IGZvcm1hdFJlYWN0VGVtcGxhdGUgZnJvbSAnLi4vLi4vZm9ybWF0dGVyL2Zvcm1hdFJlYWN0VGVtcGxhdGUnO1xuaW1wb3J0IHsgdG9SYW5nZVZhbHVlIH0gZnJvbSAnLi4vLi4vZmllbGQvdXRpbHMnO1xuXG5jb25zdCBpc092ZXJmbG93ID0gKHZhbHVlLCBtYXgsIHJhbmdlKSA9PiB7XG4gIGlmIChyYW5nZSkge1xuICAgIHJldHVybiB0b1JhbmdlVmFsdWUodmFsdWUsIHJhbmdlKS5zb21lKGl0ZW0gPT4gIWlzRW1wdHkoaXRlbSkgJiYgTnVtYmVyKGl0ZW0pID4gTnVtYmVyKG1heCkpO1xuICB9XG4gIHJldHVybiAhaXNFbXB0eSh2YWx1ZSkgJiYgTnVtYmVyKHZhbHVlKSA+IE51bWJlcihtYXgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmFuZ2VPdmVyZmxvdyh2YWx1ZTogYW55LCBwcm9wczogVmFsaWRhdG9yUHJvcHMpOiBtZXRob2RSZXR1cm4ge1xuICBjb25zdCB7IG1heCwgbGFiZWwsIGZvcm1hdCwgZGVmYXVsdFZhbGlkYXRpb25NZXNzYWdlcywgcmFuZ2UgfSA9IHByb3BzO1xuICBpZiAoIWlzTmlsKG1heCkgJiYgaXNPdmVyZmxvdyh2YWx1ZSwgbWF4LCByYW5nZSkpIHtcbiAgICBjb25zdCBpbmplY3Rpb25PcHRpb25zID0geyBtYXg6IGlzTW9tZW50KG1heCkgPyBtYXguZm9ybWF0KGZvcm1hdCkgOiBtYXgsIGxhYmVsIH07XG4gICAgY29uc3QgcnVsZU5hbWUgPSAncmFuZ2VPdmVyZmxvdyc7XG4gICAgY29uc3Qge1xuICAgICAgW3J1bGVOYW1lXTogdmFsaWRhdGlvbk1lc3NhZ2UgPSAkbCgnVmFsaWRhdG9yJywgJ3JhbmdlX292ZXJmbG93JyksXG4gICAgfSA9IGRlZmF1bHRWYWxpZGF0aW9uTWVzc2FnZXM7XG4gICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uUmVzdWx0KHtcbiAgICAgIHZhbGlkYXRpb25NZXNzYWdlOiBmb3JtYXRSZWFjdFRlbXBsYXRlKHZhbGlkYXRpb25NZXNzYWdlLCBpbmplY3Rpb25PcHRpb25zKSxcbiAgICAgIGluamVjdGlvbk9wdGlvbnMsXG4gICAgICB2YWx1ZSxcbiAgICAgIHJ1bGVOYW1lLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIl19