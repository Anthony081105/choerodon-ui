{"version":3,"sources":["/Users/huihuawk/Documents/opt/choerodon-ui/components-pro/_util/PromiseQueue.tsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;IAEqB,Y;;;AASnB,0BAAA;AAAA;;AAAA;AANA,SAAA,QAAA,GAAoB,KAApB;AAOE,2BAAY,YAAK;AACf,MAAA,KAAI,CAAC,KAAL,GAAa,EAAb;AACD,KAFD;AAGD;;;;0BAGK,O,EAAO;AACX,UAAI,CAAC,KAAK,QAAV,EAAoB;AAAA,YACV,KADU,GACA,IADA,CACV,KADU;AAElB,YAAM,KAAK,GAAG,KAAK,CAAC,OAAN,CAAc,OAAd,CAAd;;AACA,YAAI,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB,UAAA,KAAK,CAAC,MAAN,CAAa,KAAb,EAAoB,CAApB;AACD;AACF;AACF;;;wBAGM,O,EAAmB;AAAA;;AAAA,UAChB,KADgB,GACN,IADM,CAChB,KADgB;AAExB,MAAA,KAAK,CAAC,IAAN,CAAW,OAAX;AACA,aAAO,OAAO,CACX,IADI,CACC,UAAA,KAAK,EAAG;AACZ,QAAA,MAAI,CAAC,KAAL,CAAW,OAAX;;AACA,eAAO,KAAP;AACD,OAJI,WAKE,UAAA,KAAK,EAAG;AACb,QAAA,MAAI,CAAC,KAAL,CAAW,OAAX;;AACA,cAAM,KAAN;AACD,OARI,CAAP;AASD;;;;;;;;;;;;AAIC,qBAAK,QAAL,GAAgB,IAAhB;AACQ,gBAAA,K,GAAU,I,CAAV,K;;qBACJ,KAAK,CAAC,M;;;;;;uBACF,KAAK,CAAC,GAAN,E;;;iDACC,KAAK,KAAL,E;;;AAET,qBAAK,QAAL,GAAgB,KAAhB;iDACO,OAAO,CAAC,OAAR,E;;;;;;;;;;;;;;;;;;wBA7CC;AACR,aAAO,KAAK,KAAL,CAAW,MAAlB;AACD;;;;;;AANW,uBAAA,CAAX,gBAAW,CAAA,E,sBAAA,E,OAAA,E,KAAsB,CAAtB;AAeZ,uBAAA,CADC,YACD,CAAA,E,sBAAA,E,OAAA,EAQC,IARD;AAWA,uBAAA,CADC,YACD,CAAA,E,sBAAA,E,KAAA,EAYC,IAZD;AAeA,uBAAA,CADC,YACD,CAAA,E,sBAAA,E,OAAA,EASC,IATD","sourcesContent":["import { action, observable, runInAction } from 'mobx';\n\nexport default class PromiseQueue {\n  @observable queue: Promise<any>[];\n\n  queueing: boolean = false;\n\n  get length(): number {\n    return this.queue.length;\n  }\n\n  constructor() {\n    runInAction(() => {\n      this.queue = [];\n    });\n  }\n\n  @action\n  clear(promise) {\n    if (!this.queueing) {\n      const { queue } = this;\n      const index = queue.indexOf(promise);\n      if (index !== -1) {\n        queue.splice(index, 1);\n      }\n    }\n  }\n\n  @action\n  add<T>(promise: Promise<T>): Promise<T> {\n    const { queue } = this;\n    queue.push(promise);\n    return promise\n      .then(value => {\n        this.clear(promise);\n        return value;\n      })\n      .catch(error => {\n        this.clear(promise);\n        throw error;\n      });\n  }\n\n  @action\n  async ready() {\n    this.queueing = true;\n    const { queue } = this;\n    if (queue.length) {\n      await queue.pop();\n      return this.ready();\n    }\n    this.queueing = false;\n    return Promise.resolve();\n  }\n}\n"]}