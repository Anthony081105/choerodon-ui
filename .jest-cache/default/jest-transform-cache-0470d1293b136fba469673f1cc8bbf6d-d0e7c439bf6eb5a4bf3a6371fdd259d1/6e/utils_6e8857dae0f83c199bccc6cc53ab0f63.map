{"version":3,"sources":["utils.jsx"],"names":["getDisplayName","WrappedComponent","displayName","name","argumentContainer","Container","identity","obj","flattenArray","arr","Array","prototype","concat","apply","treeTraverse","path","tree","isLeafNode","errorMessage","callback","undefined","isArray","forEach","subTree","index","console","error","Object","keys","subTreeKey","flattenFields","maybeNestedFields","fields","node","normalizeValidateRules","validate","rules","validateTrigger","validateRules","map","item","newItem","trigger","push","getValidateTriggers","filter","length","reduce","pre","curr","getValueFromEvent","e","target","type","checked","value","getErrorStrs","errors","message","getParams","ns","opt","cb","names","options","isEmptyObject","hasRules","some","startsWith","str","prefix","lastIndexOf"],"mappings":"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","sourcesContent":["import hoistStatics from 'hoist-non-react-statics';\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'WrappedComponent';\n}\n\nexport function argumentContainer(Container, WrappedComponent) {\n  /* eslint no-param-reassign:0 */\n  Container.displayName = `Form(${getDisplayName(WrappedComponent)})`;\n  Container.WrappedComponent = WrappedComponent;\n  return hoistStatics(Container, WrappedComponent);\n}\n\nexport function identity(obj) {\n  return obj;\n}\n\nexport function flattenArray(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\nexport function treeTraverse(path = '', tree, isLeafNode, errorMessage, callback) {\n  if (isLeafNode(path, tree)) {\n    callback(path, tree);\n  } else if (tree === undefined) {\n    return;\n  } else if (Array.isArray(tree)) {\n    tree.forEach((subTree, index) => treeTraverse(\n      `${path}[${index}]`,\n      subTree,\n      isLeafNode,\n      errorMessage,\n      callback\n    ));\n  } else { // It's object and not a leaf node\n    if (typeof tree !== 'object') {\n      console.error(errorMessage);\n      return;\n    }\n    Object.keys(tree).forEach(subTreeKey => {\n      const subTree = tree[subTreeKey];\n      treeTraverse(\n        `${path}${path ? '.' : ''}${subTreeKey}`,\n        subTree,\n        isLeafNode,\n        errorMessage,\n        callback\n      );\n    });\n  }\n}\n\nexport function flattenFields(maybeNestedFields, isLeafNode, errorMessage) {\n  const fields = {};\n  treeTraverse(undefined, maybeNestedFields, isLeafNode, errorMessage, (path, node) => {\n    fields[path] = node;\n  });\n  return fields;\n}\n\nexport function normalizeValidateRules(validate, rules, validateTrigger) {\n  const validateRules = validate.map((item) => {\n    const newItem = {\n      ...item,\n      trigger: item.trigger || [],\n    };\n    if (typeof newItem.trigger === 'string') {\n      newItem.trigger = [newItem.trigger];\n    }\n    return newItem;\n  });\n  if (rules) {\n    validateRules.push({\n      trigger: validateTrigger ? [].concat(validateTrigger) : [],\n      rules,\n    });\n  }\n  return validateRules;\n}\n\nexport function getValidateTriggers(validateRules) {\n  return validateRules\n    .filter(item => !!item.rules && item.rules.length)\n    .map(item => item.trigger)\n    .reduce((pre, curr) => pre.concat(curr), []);\n}\n\nexport function getValueFromEvent(e) {\n  // To support custom element\n  if (!e || !e.target) {\n    return e;\n  }\n  const { target } = e;\n  return target.type === 'checkbox' ? target.checked : target.value;\n}\n\nexport function getErrorStrs(errors) {\n  if (errors) {\n    return errors.map((e) => {\n      if (e && e.message) {\n        return e.message;\n      }\n      return e;\n    });\n  }\n  return errors;\n}\n\nexport function getParams(ns, opt, cb) {\n  let names = ns;\n  let options = opt;\n  let callback = cb;\n  if (cb === undefined) {\n    if (typeof names === 'function') {\n      callback = names;\n      options = {};\n      names = undefined;\n    } else if (Array.isArray(names)) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else {\n        options = options || {};\n      }\n    } else {\n      callback = options;\n      options = names || {};\n      names = undefined;\n    }\n  }\n  return {\n    names,\n    options,\n    callback,\n  };\n}\n\nexport function isEmptyObject(obj) {\n  return Object.keys(obj).length === 0;\n}\n\nexport function hasRules(validate) {\n  if (validate) {\n    return validate.some((item) => {\n      return item.rules && item.rules.length;\n    });\n  }\n  return false;\n}\n\nexport function startsWith(str, prefix) {\n  return str.lastIndexOf(prefix, 0) === 0;\n}\n"]}