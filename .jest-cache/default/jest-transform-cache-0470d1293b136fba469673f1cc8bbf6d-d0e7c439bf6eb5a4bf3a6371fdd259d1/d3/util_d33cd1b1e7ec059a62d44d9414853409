00897e44076e6845c3fb1a654c064ba8
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrDel = arrDel;
exports.arrAdd = arrAdd;
exports.posToArr = posToArr;
exports.getOffset = getOffset;
exports.getPosition = getPosition;
exports.getNodeChildren = getNodeChildren;
exports.isCheckDisabled = isCheckDisabled;
exports.traverseTreeNodes = traverseTreeNodes;
exports.getStrictlyValue = getStrictlyValue;
exports.getFullKeyList = getFullKeyList;
exports.isParent = isParent;
exports.getNodesStatistic = getNodesStatistic;
exports.getDragNodesKeys = getDragNodesKeys;
exports.calcDropPosition = calcDropPosition;
exports.calcExpandedKeys = calcExpandedKeys;
exports.calcSelectedKeys = calcSelectedKeys;
exports.calcCheckStateConduct = calcCheckStateConduct;
exports.calcCheckedKeys = calcCheckedKeys;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _react = require("react");

var _warning = _interopRequireDefault(require("../../_util/warning"));
/* eslint no-loop-func: 0*/


function arrDel(list, value) {
  var clone = list.slice();
  var index = clone.indexOf(value);

  if (index >= 0) {
    clone.splice(index, 1);
  }

  return clone;
}

function arrAdd(list, value) {
  var clone = list.slice();

  if (clone.indexOf(value) === -1) {
    clone.push(value);
  }

  return clone;
}

function posToArr(pos) {
  return pos.split('-');
} // Only used when drag, not affect SSR.


function getOffset(ele) {
  if (!ele.getClientRects().length) {
    return {
      top: 0,
      left: 0
    };
  }

  var rect = ele.getBoundingClientRect();

  if (rect.width || rect.height) {
    var doc = ele.ownerDocument;
    var win = doc.defaultView;
    var docElem = doc.documentElement;
    return {
      top: rect.top + win.pageYOffset - docElem.clientTop,
      left: rect.left + win.pageXOffset - docElem.clientLeft
    };
  }

  return rect;
}

function getPosition(level, index) {
  return "".concat(level, "-").concat(index);
}

function getNodeChildren(children) {
  var childList = Array.isArray(children) ? children : [children];
  return childList.filter(function (child) {
    return child && child.type && child.type.isTreeNode;
  });
}

function isCheckDisabled(node) {
  var _ref = node.props || {},
      disabled = _ref.disabled,
      disableCheckbox = _ref.disableCheckbox;

  return !!(disabled || disableCheckbox);
}

function traverseTreeNodes(treeNodes, subTreeData, callback) {
  if (typeof subTreeData === 'function') {
    callback = subTreeData;
    subTreeData = false;
  }

  function processNode(node, index, parent) {
    var children = node ? node.props.children : treeNodes;
    var pos = node ? getPosition(parent.pos, index) : 0; // Filter children

    var childList = getNodeChildren(children); // Process node if is not root

    if (node) {
      var data = {
        node: node,
        index: index,
        pos: pos,
        key: node.key || pos,
        parentPos: parent.node ? parent.pos : null
      }; // Children data is not must have

      if (subTreeData) {
        // Statistic children
        var subNodes = [];

        _react.Children.forEach(childList, function (subNode, subIndex) {
          // Provide limit snapshot
          var subPos = getPosition(pos, index);
          subNodes.push({
            node: subNode,
            key: subNode.key || subPos,
            pos: subPos,
            index: subIndex
          });
        });

        data.subNodes = subNodes;
      } // Can break traverse by return false


      if (callback(data) === false) {
        return;
      }
    } // Process children node


    _react.Children.forEach(childList, function (subNode, subIndex) {
      processNode(subNode, subIndex, {
        node: node,
        pos: pos
      });
    });
  }

  processNode(null);
}
/**
 * [Legacy] Return halfChecked when it has value.
 * @param checkedKeys
 * @param halfChecked
 * @returns {*}
 */


function getStrictlyValue(checkedKeys, halfChecked) {
  if (halfChecked) {
    return {
      checked: checkedKeys,
      halfChecked: halfChecked
    };
  }

  return checkedKeys;
}

function getFullKeyList(treeNodes) {
  var keyList = [];
  traverseTreeNodes(treeNodes, function (_ref2) {
    var key = _ref2.key;
    keyList.push(key);
  });
  return keyList;
}
/**
 * Check position relation.
 * @param parentPos
 * @param childPos
 * @param directly only directly parent can be true
 * @returns {boolean}
 */


function isParent(parentPos, childPos) {
  var directly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!parentPos || !childPos || parentPos.length > childPos.length) return false;
  var parentPath = posToArr(parentPos);
  var childPath = posToArr(childPos); // Directly check

  if (directly && parentPath.length !== childPath.length - 1) return false;
  var len = parentPath.length;

  for (var i = 0; i < len; i += 1) {
    if (parentPath[i] !== childPath[i]) return false;
  }

  return true;
}
/**
 * Statistic TreeNodes info
 * @param treeNodes
 * @returns {{}}
 */


function getNodesStatistic(treeNodes) {
  var statistic = {
    keyNodes: {},
    posNodes: {},
    nodeList: []
  };
  traverseTreeNodes(treeNodes, true, function (_ref3) {
    var node = _ref3.node,
        index = _ref3.index,
        pos = _ref3.pos,
        key = _ref3.key,
        subNodes = _ref3.subNodes,
        parentPos = _ref3.parentPos;
    var data = {
      node: node,
      index: index,
      pos: pos,
      key: key,
      subNodes: subNodes,
      parentPos: parentPos
    };
    statistic.keyNodes[key] = data;
    statistic.posNodes[pos] = data;
    statistic.nodeList.push(data);
  });
  return statistic;
}

function getDragNodesKeys(treeNodes, node) {
  var _node$props = node.props,
      eventKey = _node$props.eventKey,
      pos = _node$props.pos;
  var dragNodesKeys = [];
  traverseTreeNodes(treeNodes, function (_ref4) {
    var nodePos = _ref4.pos,
        key = _ref4.key;

    if (isParent(pos, nodePos)) {
      dragNodesKeys.push(key);
    }
  });
  dragNodesKeys.push(eventKey || pos);
  return dragNodesKeys;
}

function calcDropPosition(event, treeNode) {
  var offsetTop = getOffset(treeNode.selectHandle).top;
  var offsetHeight = treeNode.selectHandle.offsetHeight;
  var pageY = event.pageY;
  var gapHeight = 2; // [Legacy] TODO: remove hard code

  if (pageY > offsetTop + offsetHeight - gapHeight) {
    return 1;
  }

  if (pageY < offsetTop + gapHeight) {
    return -1;
  }

  return 0;
}
/**
 * Auto expand all related node when sub node is expanded
 * @param keyList
 * @param props
 * @returns [string]
 */


function calcExpandedKeys(keyList, props) {
  if (!keyList) {
    return [];
  }

  var children = props.children; // Fill parent expanded keys

  var _getNodesStatistic = getNodesStatistic(children),
      keyNodes = _getNodesStatistic.keyNodes,
      nodeList = _getNodesStatistic.nodeList;

  var needExpandKeys = {};
  var needExpandPathList = []; // Fill expanded nodes

  keyList.forEach(function (key) {
    var node = keyNodes[key];

    if (node) {
      needExpandKeys[key] = true;
      needExpandPathList.push(node.pos);
    }
  }); // Match parent by path

  nodeList.forEach(function (_ref5) {
    var pos = _ref5.pos,
        key = _ref5.key;

    if (needExpandPathList.some(function (childPos) {
      return isParent(pos, childPos);
    })) {
      needExpandKeys[key] = true;
    }
  });
  var calcExpandedKeyList = Object.keys(needExpandKeys); // [Legacy] Return origin keyList if calc list is empty

  return calcExpandedKeyList.length ? calcExpandedKeyList : keyList;
}
/**
 * Return selectedKeys according with multiple prop
 * @param selectedKeys
 * @param props
 * @returns [string]
 */


function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys) {
    return undefined;
  }

  var multiple = props.multiple;

  if (multiple) {
    return selectedKeys.slice();
  }

  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }

  return selectedKeys;
}
/**
 * Check conduct is by key level. It pass though up & down.
 * When conduct target node is check means already conducted will be skip.
 * @param treeNodes
 * @param checkedKeys
 * @returns {{checkedKeys: Array, halfCheckedKeys: Array}}
 */


function calcCheckStateConduct(treeNodes, checkedKeys) {
  var _getNodesStatistic2 = getNodesStatistic(treeNodes),
      keyNodes = _getNodesStatistic2.keyNodes,
      posNodes = _getNodesStatistic2.posNodes;

  var tgtCheckedKeys = {};
  var tgtHalfCheckedKeys = {}; // Conduct up

  function conductUp(key, halfChecked) {
    if (tgtCheckedKeys[key]) return;
    var _keyNodes$key = keyNodes[key],
        _keyNodes$key$subNode = _keyNodes$key.subNodes,
        subNodes = _keyNodes$key$subNode === void 0 ? [] : _keyNodes$key$subNode,
        parentPos = _keyNodes$key.parentPos,
        node = _keyNodes$key.node;
    if (isCheckDisabled(node)) return;
    var allSubChecked = !halfChecked && subNodes.filter(function (sub) {
      return !isCheckDisabled(sub.node);
    }).every(function (sub) {
      return tgtCheckedKeys[sub.key];
    });

    if (allSubChecked) {
      tgtCheckedKeys[key] = true;
    } else {
      tgtHalfCheckedKeys[key] = true;
    }

    if (parentPos !== null) {
      conductUp(posNodes[parentPos].key, !allSubChecked);
    }
  } // Conduct down


  function conductDown(key) {
    if (tgtCheckedKeys[key]) return;
    var _keyNodes$key2 = keyNodes[key],
        _keyNodes$key2$subNod = _keyNodes$key2.subNodes,
        subNodes = _keyNodes$key2$subNod === void 0 ? [] : _keyNodes$key2$subNod,
        node = _keyNodes$key2.node;
    if (isCheckDisabled(node)) return;
    tgtCheckedKeys[key] = true;
    subNodes.forEach(function (sub) {
      conductDown(sub.key);
    });
  }

  function conduct(key) {
    if (!keyNodes[key]) {
      (0, _warning["default"])(false, "'".concat(key, "' does not exist in the tree."));
      return;
    }

    var _keyNodes$key3 = keyNodes[key],
        _keyNodes$key3$subNod = _keyNodes$key3.subNodes,
        subNodes = _keyNodes$key3$subNod === void 0 ? [] : _keyNodes$key3$subNod,
        parentPos = _keyNodes$key3.parentPos,
        node = _keyNodes$key3.node;
    tgtCheckedKeys[key] = true;
    if (isCheckDisabled(node)) return; // Conduct down

    subNodes.filter(function (sub) {
      return !isCheckDisabled(sub.node);
    }).forEach(function (sub) {
      conductDown(sub.key);
    }); // Conduct up

    if (parentPos !== null) {
      conductUp(posNodes[parentPos].key);
    }
  }

  checkedKeys.forEach(function (key) {
    conduct(key);
  });
  return {
    checkedKeys: Object.keys(tgtCheckedKeys),
    halfCheckedKeys: Object.keys(tgtHalfCheckedKeys).filter(function (key) {
      return !tgtCheckedKeys[key];
    })
  };
}
/**
 * Calculate the value of checked and halfChecked keys.
 * This should be only run in init or props changed.
 */


function calcCheckedKeys(keys, props) {
  var checkable = props.checkable,
      children = props.children,
      checkStrictly = props.checkStrictly;

  if (!checkable || !keys) {
    return null;
  } // Convert keys to object format


  var keyProps;

  if (Array.isArray(keys)) {
    // [Legacy] Follow the api doc
    keyProps = {
      checkedKeys: keys,
      halfCheckedKeys: undefined
    };
  } else if ((0, _typeof2["default"])(keys) === 'object') {
    keyProps = {
      checkedKeys: keys.checked || undefined,
      halfCheckedKeys: keys.halfChecked || undefined
    };
  } else {
    (0, _warning["default"])(false, '`CheckedKeys` is not an array or an object');
    return null;
  } // Do nothing if is checkStrictly mode


  if (checkStrictly) {
    return keyProps;
  } // Conduct calculate the check status


  var _keyProps = keyProps,
      _keyProps$checkedKeys = _keyProps.checkedKeys,
      checkedKeys = _keyProps$checkedKeys === void 0 ? [] : _keyProps$checkedKeys;
  return calcCheckStateConduct(children, checkedKeys);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRyZWUvdXRpbC5qc3giXSwibmFtZXMiOlsiY2xvbmUiLCJsaXN0IiwiaW5kZXgiLCJwb3MiLCJlbGUiLCJ0b3AiLCJsZWZ0IiwicmVjdCIsImRvYyIsIndpbiIsImRvY0VsZW0iLCJjbGllbnRMZWZ0IiwiY2hpbGRMaXN0IiwiQXJyYXkiLCJjaGlsZCIsImRpc2FibGVkIiwiZGlzYWJsZUNoZWNrYm94Iiwibm9kZSIsImNhbGxiYWNrIiwic3ViVHJlZURhdGEiLCJjaGlsZHJlbiIsImdldFBvc2l0aW9uIiwicGFyZW50IiwiZ2V0Tm9kZUNoaWxkcmVuIiwiZGF0YSIsImtleSIsInBhcmVudFBvcyIsInN1Yk5vZGVzIiwiQ2hpbGRyZW4iLCJzdWJQb3MiLCJzdWJOb2RlIiwic3ViSW5kZXgiLCJwcm9jZXNzTm9kZSIsImNoZWNrZWQiLCJoYWxmQ2hlY2tlZCIsImtleUxpc3QiLCJ0cmF2ZXJzZVRyZWVOb2RlcyIsImRpcmVjdGx5IiwiY2hpbGRQb3MiLCJwYXJlbnRQYXRoIiwicG9zVG9BcnIiLCJjaGlsZFBhdGgiLCJsZW4iLCJpIiwic3RhdGlzdGljIiwia2V5Tm9kZXMiLCJwb3NOb2RlcyIsIm5vZGVMaXN0IiwiZXZlbnRLZXkiLCJkcmFnTm9kZXNLZXlzIiwibm9kZVBvcyIsImlzUGFyZW50Iiwib2Zmc2V0VG9wIiwiZ2V0T2Zmc2V0IiwidHJlZU5vZGUiLCJvZmZzZXRIZWlnaHQiLCJwYWdlWSIsImV2ZW50IiwiZ2FwSGVpZ2h0IiwicHJvcHMiLCJnZXROb2Rlc1N0YXRpc3RpYyIsIm5lZWRFeHBhbmRLZXlzIiwibmVlZEV4cGFuZFBhdGhMaXN0IiwiY2FsY0V4cGFuZGVkS2V5TGlzdCIsIk9iamVjdCIsIm11bHRpcGxlIiwic2VsZWN0ZWRLZXlzIiwidGd0Q2hlY2tlZEtleXMiLCJ0Z3RIYWxmQ2hlY2tlZEtleXMiLCJpc0NoZWNrRGlzYWJsZWQiLCJhbGxTdWJDaGVja2VkIiwic3ViIiwiY29uZHVjdFVwIiwiY29uZHVjdERvd24iLCJjaGVja2VkS2V5cyIsImNvbmR1Y3QiLCJoYWxmQ2hlY2tlZEtleXMiLCJjaGVja2FibGUiLCJjaGVja1N0cmljdGx5Iiwia2V5UHJvcHMiLCJ1bmRlZmluZWQiLCJrZXlzIiwiY2FsY0NoZWNrU3RhdGVDb25kdWN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsSUFBQSxNQUFBLEdBQUEsT0FBQSxDQUFBLE9BQUEsQ0FBQTs7QUFDQSxJQUFBLFFBQUEsR0FBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxxQkFBQSxDQUFBLENBQUE7QUFGQTs7O0FBSU8sU0FBQSxNQUFBLENBQUEsSUFBQSxFQUFBLEtBQUEsRUFBNkI7QUFDbEMsTUFBTUEsS0FBSyxHQUFHQyxJQUFJLENBQWxCLEtBQWNBLEVBQWQ7QUFDQSxNQUFNQyxLQUFLLEdBQUdGLEtBQUssQ0FBTEEsT0FBQUEsQ0FBZCxLQUFjQSxDQUFkOztBQUNBLE1BQUlFLEtBQUssSUFBVCxDQUFBLEVBQWdCO0FBQ2RGLElBQUFBLEtBQUssQ0FBTEEsTUFBQUEsQ0FBQUEsS0FBQUEsRUFBQUEsQ0FBQUE7QUFDRDs7QUFDRCxTQUFBLEtBQUE7QUFDRDs7QUFFTSxTQUFBLE1BQUEsQ0FBQSxJQUFBLEVBQUEsS0FBQSxFQUE2QjtBQUNsQyxNQUFNQSxLQUFLLEdBQUdDLElBQUksQ0FBbEIsS0FBY0EsRUFBZDs7QUFDQSxNQUFJRCxLQUFLLENBQUxBLE9BQUFBLENBQUFBLEtBQUFBLE1BQXlCLENBQTdCLENBQUEsRUFBaUM7QUFDL0JBLElBQUFBLEtBQUssQ0FBTEEsSUFBQUEsQ0FBQUEsS0FBQUE7QUFDRDs7QUFDRCxTQUFBLEtBQUE7QUFDRDs7QUFFTSxTQUFBLFFBQUEsQ0FBQSxHQUFBLEVBQXVCO0FBQzVCLFNBQU9HLEdBQUcsQ0FBSEEsS0FBQUEsQ0FBUCxHQUFPQSxDQUFQO0VBR0Y7OztBQUNPLFNBQUEsU0FBQSxDQUFBLEdBQUEsRUFBd0I7QUFDN0IsTUFBSSxDQUFDQyxHQUFHLENBQUhBLGNBQUFBLEdBQUwsTUFBQSxFQUFrQztB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QVhEO0FBRkYsR0FBQSxNQU1PLElBQUksQ0FBQSxHQUFBLFFBQUEsQ0FBQSxTQUFBLENBQUEsRUFBQSxJQUFBLE1BQUosUUFBQSxFQUE4QjtBQUNuQ0EsSUFBQUEsUUFBUSxHQUFHO0FBQ1RMLE1BQUFBLFdBQVcsRUFBRU8sSUFBSSxDQUFKQSxPQUFBQSxJQURKLFNBQUE7QUFFVEwsTUFBQUEsZUFBZSxFQUFFSyxJQUFJLENBQUpBLFdBQUFBLElBQW9CRDtBQUY1QixLQUFYRDtBQURLLEdBQUEsTUFLQTtBQUNMLEtBQUEsR0FBQSxRQUFBLENBQUEsU0FBQSxDQUFBLEVBQUEsS0FBQSxFQUFBLDRDQUFBO0FBQ0EsV0FBQSxJQUFBO0FBdEJ5QyxHQUFBLENBeUIzQzs7O0FBQ0EsTUFBQSxhQUFBLEVBQW1CO0FBQ2pCLFdBQUEsUUFBQTtBQTNCeUMsR0FBQSxDQThCM0M7OztBQTlCMkMsTUFBQSxTQUFBLEdBQUEsUUFBQTtBQUFBLE1BQUEscUJBQUEsR0FBQSxTQUFBLENBQUEsV0FBQTtBQUFBLE1BK0JuQ0wsV0EvQm1DLEdBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxFQUFBLEdBQUEscUJBQUE7QUFnQzNDLFNBQU9RLHFCQUFxQixDQUFBLFFBQUEsRUFBNUIsV0FBNEIsQ0FBNUI7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby1sb29wLWZ1bmM6IDAqL1xuaW1wb3J0IHsgQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuLi8uLi9fdXRpbC93YXJuaW5nJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFyckRlbChsaXN0LCB2YWx1ZSkge1xuICBjb25zdCBjbG9uZSA9IGxpc3Quc2xpY2UoKTtcbiAgY29uc3QgaW5kZXggPSBjbG9uZS5pbmRleE9mKHZhbHVlKTtcbiAgaWYgKGluZGV4ID49IDApIHtcbiAgICBjbG9uZS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyckFkZChsaXN0LCB2YWx1ZSkge1xuICBjb25zdCBjbG9uZSA9IGxpc3Quc2xpY2UoKTtcbiAgaWYgKGNsb25lLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIGNsb25lLnB1c2godmFsdWUpO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvc1RvQXJyKHBvcykge1xuICByZXR1cm4gcG9zLnNwbGl0KCctJyk7XG59XG5cbi8vIE9ubHkgdXNlZCB3aGVuIGRyYWcsIG5vdCBhZmZlY3QgU1NSLlxuZXhwb3J0IGZ1bmN0aW9uIGdldE9mZnNldChlbGUpIHtcbiAgaWYgKCFlbGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpIHtcbiAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgfVxuXG4gIGNvbnN0IHJlY3QgPSBlbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGlmIChyZWN0LndpZHRoIHx8IHJlY3QuaGVpZ2h0KSB7XG4gICAgY29uc3QgZG9jID0gZWxlLm93bmVyRG9jdW1lbnQ7XG4gICAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgIGNvbnN0IGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdCxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbihsZXZlbCwgaW5kZXgpIHtcbiAgcmV0dXJuIGAke2xldmVsfS0ke2luZGV4fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgY29uc3QgY2hpbGRMaXN0ID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbiA6IFtjaGlsZHJlbl07XG4gIHJldHVybiBjaGlsZExpc3QuZmlsdGVyKGNoaWxkID0+IGNoaWxkICYmIGNoaWxkLnR5cGUgJiYgY2hpbGQudHlwZS5pc1RyZWVOb2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hlY2tEaXNhYmxlZChub2RlKSB7XG4gIGNvbnN0IHsgZGlzYWJsZWQsIGRpc2FibGVDaGVja2JveCB9ID0gbm9kZS5wcm9wcyB8fCB7fTtcbiAgcmV0dXJuICEhKGRpc2FibGVkIHx8IGRpc2FibGVDaGVja2JveCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZVRyZWVOb2Rlcyh0cmVlTm9kZXMsIHN1YlRyZWVEYXRhLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1YlRyZWVEYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdWJUcmVlRGF0YTtcbiAgICBzdWJUcmVlRGF0YSA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc05vZGUobm9kZSwgaW5kZXgsIHBhcmVudCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZSA/IG5vZGUucHJvcHMuY2hpbGRyZW4gOiB0cmVlTm9kZXM7XG4gICAgY29uc3QgcG9zID0gbm9kZSA/IGdldFBvc2l0aW9uKHBhcmVudC5wb3MsIGluZGV4KSA6IDA7XG5cbiAgICAvLyBGaWx0ZXIgY2hpbGRyZW5cbiAgICBjb25zdCBjaGlsZExpc3QgPSBnZXROb2RlQ2hpbGRyZW4oY2hpbGRyZW4pO1xuXG4gICAgLy8gUHJvY2VzcyBub2RlIGlmIGlzIG5vdCByb290XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBwb3MsXG4gICAgICAgIGtleTogbm9kZS5rZXkgfHwgcG9zLFxuICAgICAgICBwYXJlbnRQb3M6IHBhcmVudC5ub2RlID8gcGFyZW50LnBvcyA6IG51bGwsXG4gICAgICB9O1xuXG4gICAgICAvLyBDaGlsZHJlbiBkYXRhIGlzIG5vdCBtdXN0IGhhdmVcbiAgICAgIGlmIChzdWJUcmVlRGF0YSkge1xuICAgICAgICAvLyBTdGF0aXN0aWMgY2hpbGRyZW5cbiAgICAgICAgY29uc3Qgc3ViTm9kZXMgPSBbXTtcbiAgICAgICAgQ2hpbGRyZW4uZm9yRWFjaChjaGlsZExpc3QsIChzdWJOb2RlLCBzdWJJbmRleCkgPT4ge1xuICAgICAgICAgIC8vIFByb3ZpZGUgbGltaXQgc25hcHNob3RcbiAgICAgICAgICBjb25zdCBzdWJQb3MgPSBnZXRQb3NpdGlvbihwb3MsIGluZGV4KTtcbiAgICAgICAgICBzdWJOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgIG5vZGU6IHN1Yk5vZGUsXG4gICAgICAgICAgICBrZXk6IHN1Yk5vZGUua2V5IHx8IHN1YlBvcyxcbiAgICAgICAgICAgIHBvczogc3ViUG9zLFxuICAgICAgICAgICAgaW5kZXg6IHN1YkluZGV4LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZGF0YS5zdWJOb2RlcyA9IHN1Yk5vZGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBDYW4gYnJlYWsgdHJhdmVyc2UgYnkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoY2FsbGJhY2soZGF0YSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGNoaWxkcmVuIG5vZGVcbiAgICBDaGlsZHJlbi5mb3JFYWNoKGNoaWxkTGlzdCwgKHN1Yk5vZGUsIHN1YkluZGV4KSA9PiB7XG4gICAgICBwcm9jZXNzTm9kZShzdWJOb2RlLCBzdWJJbmRleCwgeyBub2RlLCBwb3MgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwcm9jZXNzTm9kZShudWxsKTtcbn1cblxuLyoqXG4gKiBbTGVnYWN5XSBSZXR1cm4gaGFsZkNoZWNrZWQgd2hlbiBpdCBoYXMgdmFsdWUuXG4gKiBAcGFyYW0gY2hlY2tlZEtleXNcbiAqIEBwYXJhbSBoYWxmQ2hlY2tlZFxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHJpY3RseVZhbHVlKGNoZWNrZWRLZXlzLCBoYWxmQ2hlY2tlZCkge1xuICBpZiAoaGFsZkNoZWNrZWQpIHtcbiAgICByZXR1cm4geyBjaGVja2VkOiBjaGVja2VkS2V5cywgaGFsZkNoZWNrZWQgfTtcbiAgfVxuICByZXR1cm4gY2hlY2tlZEtleXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdWxsS2V5TGlzdCh0cmVlTm9kZXMpIHtcbiAgY29uc3Qga2V5TGlzdCA9IFtdO1xuICB0cmF2ZXJzZVRyZWVOb2Rlcyh0cmVlTm9kZXMsICh7IGtleSB9KSA9PiB7XG4gICAga2V5TGlzdC5wdXNoKGtleSk7XG4gIH0pO1xuICByZXR1cm4ga2V5TGlzdDtcbn1cblxuLyoqXG4gKiBDaGVjayBwb3NpdGlvbiByZWxhdGlvbi5cbiAqIEBwYXJhbSBwYXJlbnRQb3NcbiAqIEBwYXJhbSBjaGlsZFBvc1xuICogQHBhcmFtIGRpcmVjdGx5IG9ubHkgZGlyZWN0bHkgcGFyZW50IGNhbiBiZSB0cnVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGFyZW50KHBhcmVudFBvcywgY2hpbGRQb3MsIGRpcmVjdGx5ID0gZmFsc2UpIHtcbiAgaWYgKCFwYXJlbnRQb3MgfHwgIWNoaWxkUG9zIHx8IHBhcmVudFBvcy5sZW5ndGggPiBjaGlsZFBvcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBjb25zdCBwYXJlbnRQYXRoID0gcG9zVG9BcnIocGFyZW50UG9zKTtcbiAgY29uc3QgY2hpbGRQYXRoID0gcG9zVG9BcnIoY2hpbGRQb3MpO1xuXG4gIC8vIERpcmVjdGx5IGNoZWNrXG4gIGlmIChkaXJlY3RseSAmJiBwYXJlbnRQYXRoLmxlbmd0aCAhPT0gY2hpbGRQYXRoLmxlbmd0aCAtIDEpIHJldHVybiBmYWxzZTtcblxuICBjb25zdCBsZW4gPSBwYXJlbnRQYXRoLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGlmIChwYXJlbnRQYXRoW2ldICE9PSBjaGlsZFBhdGhbaV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFN0YXRpc3RpYyBUcmVlTm9kZXMgaW5mb1xuICogQHBhcmFtIHRyZWVOb2Rlc1xuICogQHJldHVybnMge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZXNTdGF0aXN0aWModHJlZU5vZGVzKSB7XG4gIGNvbnN0IHN0YXRpc3RpYyA9IHtcbiAgICBrZXlOb2Rlczoge30sXG4gICAgcG9zTm9kZXM6IHt9LFxuICAgIG5vZGVMaXN0OiBbXSxcbiAgfTtcblxuICB0cmF2ZXJzZVRyZWVOb2Rlcyh0cmVlTm9kZXMsIHRydWUsICh7IG5vZGUsIGluZGV4LCBwb3MsIGtleSwgc3ViTm9kZXMsIHBhcmVudFBvcyB9KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHsgbm9kZSwgaW5kZXgsIHBvcywga2V5LCBzdWJOb2RlcywgcGFyZW50UG9zIH07XG4gICAgc3RhdGlzdGljLmtleU5vZGVzW2tleV0gPSBkYXRhO1xuICAgIHN0YXRpc3RpYy5wb3NOb2Rlc1twb3NdID0gZGF0YTtcbiAgICBzdGF0aXN0aWMubm9kZUxpc3QucHVzaChkYXRhKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHN0YXRpc3RpYztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERyYWdOb2Rlc0tleXModHJlZU5vZGVzLCBub2RlKSB7XG4gIGNvbnN0IHsgZXZlbnRLZXksIHBvcyB9ID0gbm9kZS5wcm9wcztcbiAgY29uc3QgZHJhZ05vZGVzS2V5cyA9IFtdO1xuXG4gIHRyYXZlcnNlVHJlZU5vZGVzKHRyZWVOb2RlcywgKHsgcG9zOiBub2RlUG9zLCBrZXkgfSkgPT4ge1xuICAgIGlmIChpc1BhcmVudChwb3MsIG5vZGVQb3MpKSB7XG4gICAgICBkcmFnTm9kZXNLZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gIH0pO1xuICBkcmFnTm9kZXNLZXlzLnB1c2goZXZlbnRLZXkgfHwgcG9zKTtcbiAgcmV0dXJuIGRyYWdOb2Rlc0tleXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjRHJvcFBvc2l0aW9uKGV2ZW50LCB0cmVlTm9kZSkge1xuICBjb25zdCBvZmZzZXRUb3AgPSBnZXRPZmZzZXQodHJlZU5vZGUuc2VsZWN0SGFuZGxlKS50b3A7XG4gIGNvbnN0IG9mZnNldEhlaWdodCA9IHRyZWVOb2RlLnNlbGVjdEhhbmRsZS5vZmZzZXRIZWlnaHQ7XG4gIGNvbnN0IHBhZ2VZID0gZXZlbnQucGFnZVk7XG4gIGNvbnN0IGdhcEhlaWdodCA9IDI7IC8vIFtMZWdhY3ldIFRPRE86IHJlbW92ZSBoYXJkIGNvZGVcbiAgaWYgKHBhZ2VZID4gb2Zmc2V0VG9wICsgb2Zmc2V0SGVpZ2h0IC0gZ2FwSGVpZ2h0KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKHBhZ2VZIDwgb2Zmc2V0VG9wICsgZ2FwSGVpZ2h0KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIEF1dG8gZXhwYW5kIGFsbCByZWxhdGVkIG5vZGUgd2hlbiBzdWIgbm9kZSBpcyBleHBhbmRlZFxuICogQHBhcmFtIGtleUxpc3RcbiAqIEBwYXJhbSBwcm9wc1xuICogQHJldHVybnMgW3N0cmluZ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGNFeHBhbmRlZEtleXMoa2V5TGlzdCwgcHJvcHMpIHtcbiAgaWYgKCFrZXlMaXN0KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcHJvcHM7XG5cbiAgLy8gRmlsbCBwYXJlbnQgZXhwYW5kZWQga2V5c1xuICBjb25zdCB7IGtleU5vZGVzLCBub2RlTGlzdCB9ID0gZ2V0Tm9kZXNTdGF0aXN0aWMoY2hpbGRyZW4pO1xuICBjb25zdCBuZWVkRXhwYW5kS2V5cyA9IHt9O1xuICBjb25zdCBuZWVkRXhwYW5kUGF0aExpc3QgPSBbXTtcblxuICAvLyBGaWxsIGV4cGFuZGVkIG5vZGVzXG4gIGtleUxpc3QuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBrZXlOb2Rlc1trZXldO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBuZWVkRXhwYW5kS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgIG5lZWRFeHBhbmRQYXRoTGlzdC5wdXNoKG5vZGUucG9zKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1hdGNoIHBhcmVudCBieSBwYXRoXG4gIG5vZGVMaXN0LmZvckVhY2goKHsgcG9zLCBrZXkgfSkgPT4ge1xuICAgIGlmIChuZWVkRXhwYW5kUGF0aExpc3Quc29tZShjaGlsZFBvcyA9PiBpc1BhcmVudChwb3MsIGNoaWxkUG9zKSkpIHtcbiAgICAgIG5lZWRFeHBhbmRLZXlzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgY2FsY0V4cGFuZGVkS2V5TGlzdCA9IE9iamVjdC5rZXlzKG5lZWRFeHBhbmRLZXlzKTtcblxuICAvLyBbTGVnYWN5XSBSZXR1cm4gb3JpZ2luIGtleUxpc3QgaWYgY2FsYyBsaXN0IGlzIGVtcHR5XG4gIHJldHVybiBjYWxjRXhwYW5kZWRLZXlMaXN0Lmxlbmd0aCA/IGNhbGNFeHBhbmRlZEtleUxpc3QgOiBrZXlMaXN0O1xufVxuXG4vKipcbiAqIFJldHVybiBzZWxlY3RlZEtleXMgYWNjb3JkaW5nIHdpdGggbXVsdGlwbGUgcHJvcFxuICogQHBhcmFtIHNlbGVjdGVkS2V5c1xuICogQHBhcmFtIHByb3BzXG4gKiBAcmV0dXJucyBbc3RyaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY1NlbGVjdGVkS2V5cyhzZWxlY3RlZEtleXMsIHByb3BzKSB7XG4gIGlmICghc2VsZWN0ZWRLZXlzKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHsgbXVsdGlwbGUgfSA9IHByb3BzO1xuICBpZiAobXVsdGlwbGUpIHtcbiAgICByZXR1cm4gc2VsZWN0ZWRLZXlzLnNsaWNlKCk7XG4gIH1cblxuICBpZiAoc2VsZWN0ZWRLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBbc2VsZWN0ZWRLZXlzWzBdXTtcbiAgfVxuICByZXR1cm4gc2VsZWN0ZWRLZXlzO1xufVxuXG4vKipcbiAqIENoZWNrIGNvbmR1Y3QgaXMgYnkga2V5IGxldmVsLiBJdCBwYXNzIHRob3VnaCB1cCAmIGRvd24uXG4gKiBXaGVuIGNvbmR1Y3QgdGFyZ2V0IG5vZGUgaXMgY2hlY2sgbWVhbnMgYWxyZWFkeSBjb25kdWN0ZWQgd2lsbCBiZSBza2lwLlxuICogQHBhcmFtIHRyZWVOb2Rlc1xuICogQHBhcmFtIGNoZWNrZWRLZXlzXG4gKiBAcmV0dXJucyB7e2NoZWNrZWRLZXlzOiBBcnJheSwgaGFsZkNoZWNrZWRLZXlzOiBBcnJheX19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjQ2hlY2tTdGF0ZUNvbmR1Y3QodHJlZU5vZGVzLCBjaGVja2VkS2V5cykge1xuICBjb25zdCB7IGtleU5vZGVzLCBwb3NOb2RlcyB9ID0gZ2V0Tm9kZXNTdGF0aXN0aWModHJlZU5vZGVzKTtcblxuICBjb25zdCB0Z3RDaGVja2VkS2V5cyA9IHt9O1xuICBjb25zdCB0Z3RIYWxmQ2hlY2tlZEtleXMgPSB7fTtcblxuICAvLyBDb25kdWN0IHVwXG4gIGZ1bmN0aW9uIGNvbmR1Y3RVcChrZXksIGhhbGZDaGVja2VkKSB7XG4gICAgaWYgKHRndENoZWNrZWRLZXlzW2tleV0pIHJldHVybjtcblxuICAgIGNvbnN0IHsgc3ViTm9kZXMgPSBbXSwgcGFyZW50UG9zLCBub2RlIH0gPSBrZXlOb2Rlc1trZXldO1xuICAgIGlmIChpc0NoZWNrRGlzYWJsZWQobm9kZSkpIHJldHVybjtcblxuICAgIGNvbnN0IGFsbFN1YkNoZWNrZWQgPVxuICAgICAgIWhhbGZDaGVja2VkICYmXG4gICAgICBzdWJOb2Rlcy5maWx0ZXIoc3ViID0+ICFpc0NoZWNrRGlzYWJsZWQoc3ViLm5vZGUpKS5ldmVyeShzdWIgPT4gdGd0Q2hlY2tlZEtleXNbc3ViLmtleV0pO1xuXG4gICAgaWYgKGFsbFN1YkNoZWNrZWQpIHtcbiAgICAgIHRndENoZWNrZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0Z3RIYWxmQ2hlY2tlZEtleXNba2V5XSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudFBvcyAhPT0gbnVsbCkge1xuICAgICAgY29uZHVjdFVwKHBvc05vZGVzW3BhcmVudFBvc10ua2V5LCAhYWxsU3ViQ2hlY2tlZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29uZHVjdCBkb3duXG4gIGZ1bmN0aW9uIGNvbmR1Y3REb3duKGtleSkge1xuICAgIGlmICh0Z3RDaGVja2VkS2V5c1trZXldKSByZXR1cm47XG4gICAgY29uc3QgeyBzdWJOb2RlcyA9IFtdLCBub2RlIH0gPSBrZXlOb2Rlc1trZXldO1xuXG4gICAgaWYgKGlzQ2hlY2tEaXNhYmxlZChub2RlKSkgcmV0dXJuO1xuXG4gICAgdGd0Q2hlY2tlZEtleXNba2V5XSA9IHRydWU7XG5cbiAgICBzdWJOb2Rlcy5mb3JFYWNoKHN1YiA9PiB7XG4gICAgICBjb25kdWN0RG93bihzdWIua2V5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmR1Y3Qoa2V5KSB7XG4gICAgaWYgKCFrZXlOb2Rlc1trZXldKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBgJyR7a2V5fScgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHRyZWUuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBzdWJOb2RlcyA9IFtdLCBwYXJlbnRQb3MsIG5vZGUgfSA9IGtleU5vZGVzW2tleV07XG5cbiAgICB0Z3RDaGVja2VkS2V5c1trZXldID0gdHJ1ZTtcblxuICAgIGlmIChpc0NoZWNrRGlzYWJsZWQobm9kZSkpIHJldHVybjtcblxuICAgIC8vIENvbmR1Y3QgZG93blxuICAgIHN1Yk5vZGVzXG4gICAgICAuZmlsdGVyKHN1YiA9PiAhaXNDaGVja0Rpc2FibGVkKHN1Yi5ub2RlKSlcbiAgICAgIC5mb3JFYWNoKHN1YiA9PiB7XG4gICAgICAgIGNvbmR1Y3REb3duKHN1Yi5rZXkpO1xuICAgICAgfSk7XG5cbiAgICAvLyBDb25kdWN0IHVwXG4gICAgaWYgKHBhcmVudFBvcyAhPT0gbnVsbCkge1xuICAgICAgY29uZHVjdFVwKHBvc05vZGVzW3BhcmVudFBvc10ua2V5KTtcbiAgICB9XG4gIH1cblxuICBjaGVja2VkS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uZHVjdChrZXkpO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGNoZWNrZWRLZXlzOiBPYmplY3Qua2V5cyh0Z3RDaGVja2VkS2V5cyksXG4gICAgaGFsZkNoZWNrZWRLZXlzOiBPYmplY3Qua2V5cyh0Z3RIYWxmQ2hlY2tlZEtleXMpLmZpbHRlcihrZXkgPT4gIXRndENoZWNrZWRLZXlzW2tleV0pLFxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCBhbmQgaGFsZkNoZWNrZWQga2V5cy5cbiAqIFRoaXMgc2hvdWxkIGJlIG9ubHkgcnVuIGluIGluaXQgb3IgcHJvcHMgY2hhbmdlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGNDaGVja2VkS2V5cyhrZXlzLCBwcm9wcykge1xuICBjb25zdCB7IGNoZWNrYWJsZSwgY2hpbGRyZW4sIGNoZWNrU3RyaWN0bHkgfSA9IHByb3BzO1xuXG4gIGlmICghY2hlY2thYmxlIHx8ICFrZXlzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDb252ZXJ0IGtleXMgdG8gb2JqZWN0IGZvcm1hdFxuICBsZXQga2V5UHJvcHM7XG4gIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgLy8gW0xlZ2FjeV0gRm9sbG93IHRoZSBhcGkgZG9jXG4gICAga2V5UHJvcHMgPSB7XG4gICAgICBjaGVja2VkS2V5czoga2V5cyxcbiAgICAgIGhhbGZDaGVja2VkS2V5czogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGtleXMgPT09ICdvYmplY3QnKSB7XG4gICAga2V5UHJvcHMgPSB7XG4gICAgICBjaGVja2VkS2V5czoga2V5cy5jaGVja2VkIHx8IHVuZGVmaW5lZCxcbiAgICAgIGhhbGZDaGVja2VkS2V5czoga2V5cy5oYWxmQ2hlY2tlZCB8fCB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnYENoZWNrZWRLZXlzYCBpcyBub3QgYW4gYXJyYXkgb3IgYW4gb2JqZWN0Jyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBEbyBub3RoaW5nIGlmIGlzIGNoZWNrU3RyaWN0bHkgbW9kZVxuICBpZiAoY2hlY2tTdHJpY3RseSkge1xuICAgIHJldHVybiBrZXlQcm9wcztcbiAgfVxuXG4gIC8vIENvbmR1Y3QgY2FsY3VsYXRlIHRoZSBjaGVjayBzdGF0dXNcbiAgY29uc3QgeyBjaGVja2VkS2V5cyA9IFtdIH0gPSBrZXlQcm9wcztcbiAgcmV0dXJuIGNhbGNDaGVja1N0YXRlQ29uZHVjdChjaGlsZHJlbiwgY2hlY2tlZEtleXMpO1xufVxuIl19