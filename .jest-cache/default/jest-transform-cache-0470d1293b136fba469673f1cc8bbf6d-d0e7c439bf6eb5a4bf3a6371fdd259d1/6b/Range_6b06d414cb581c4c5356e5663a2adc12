2f52f2960851178fa57c34adc8b54700
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _Track = _interopRequireDefault(require("./common/Track"));

var _createSlider = _interopRequireDefault(require("./common/createSlider"));

var utils = _interopRequireWildcard(require("./utils"));

/* eslint-disable react/prop-types */
var Range =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2["default"])(Range, _Component);

  function Range(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, Range);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Range).call(this, props));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onEnd", function () {
      _this.removeDocumentEvents();

      _this.props.onAfterChange(_this.getValue());
    });
    var count = props.count,
        min = props.min,
        max = props.max;
    var initialValue = Array.apply(null, Array(count + 1)).map(function () {
      return min;
    });
    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;
    var value = props.value !== undefined ? props.value : defaultValue;
    var bounds = value.map(function (v, i) {
      return _this.trimAlignValue(v, i);
    });
    var recent = bounds[0] === max ? 0 : bounds.length - 1;
    _this.state = {
      handle: null,
      recent: recent,
      bounds: bounds
    };
    return _this;
  }

  (0, _createClass2["default"])(Range, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (!('value' in nextProps || 'min' in nextProps || 'max' in nextProps)) return;

      if (this.props.min === nextProps.min && this.props.max === nextProps.max && (0, _isEqual["default"])(this.props.value, nextProps.value)) {
        return;
      }

      var bounds = this.state.bounds;
      var value = nextProps.value || bounds;
      var nextBounds = value.map(function (v, i) {
        return _this2.trimAlignValue(v, i, nextProps);
      });
      if (nextBounds.length === bounds.length && nextBounds.every(function (v, i) {
        return v === bounds[i];
      })) return;
      this.setState({
        bounds: nextBounds
      });

      if (bounds.some(function (v) {
        return utils.isValueOutOfRange(v, nextProps);
      })) {
        var newValues = value.map(function (v) {
          return utils.ensureValueInRange(v, nextProps);
        });
        this.props.onChange(newValues);
      }
    }
  }, {
    key: "onChange",
    value: function onChange(state) {
      var props = this.props;
      var isNotControlled = !('value' in props);

      if (isNotControlled) {
        this.setState(state);
      } else if (state.handle !== undefined) {
        this.setState({
          handle: state.handle
        });
      }

      var data = (0, _objectSpread2["default"])({}, this.state, {}, state);
      var changedValue = data.bounds;
      props.onChange(changedValue);
    }
  }, {
    key: "onStart",
    value: function onStart(position) {
      var props = this.props;
      var state = this.state;
      var bounds = this.getValue();
      props.onBeforeChange(bounds);
      var value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;
      var closestBound = this.getClosestBound(value);
      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);
      this.setState({
        handle: this.prevMovedHandleIndex,
        recent: this.prevMovedHandleIndex
      });
      var prevValue = bounds[this.prevMovedHandleIndex];
      if (value === prevValue) return;
      var nextBounds = (0, _toConsumableArray2["default"])(state.bounds);
      nextBounds[this.prevMovedHandleIndex] = value;
      this.onChange({
        bounds: nextBounds
      });
    }
  }, {
    key: "onMove",
    value: function onMove(e, position) {
      utils.pauseEvent(e);
      var state = this.state;
      var value = this.calcValueByPos(position);
      var oldValue = state.bounds[state.handle];
      if (value === oldValue) return;
      this.moveTo(value);
    }
  }, {
    key: "onKeyboard",
    value: function onKeyboard(e) {
      var valueMutator = utils.getKeyboardValueMutator(e);

      if (valueMutator) {
        utils.pauseEvent(e);
        var state = this.state,
            props = this.props;
        var bounds = state.bounds,
            handle = state.handle;
        var oldValue = bounds[handle];
        var mutatedValue = valueMutator(oldValue, props);
        var value = this.trimAlignValue(mutatedValue);
        if (value === oldValue) return;
        var isFromKeyboardEvent = true;
        this.moveTo(value, isFromKeyboardEvent);
      }
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this.state.bounds;
    }
  }, {
    key: "getClosestBound",
    value: function getClosestBound(value) {
      var bounds = this.state.bounds;
      var closestBound = 0;

      for (var i = 1; i < bounds.length - 1; ++i) {
        if (value > bounds[i]) {
          closestBound = i;
        }
      }

      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {
        closestBound = closestBound + 1;
      }

      return closestBound;
    }
  }, {
    key: "getBoundNeedMoving",
    value: function getBoundNeedMoving(value, closestBound) {
      var _this$state = this.state,
          bounds = _this$state.bounds,
          recent = _this$state.recent;
      var boundNeedMoving = closestBound;
      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];

      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {
        boundNeedMoving = recent;
      }

      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {
        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;
      }

      return boundNeedMoving;
    }
  }, {
    key: "getLowerBound",
    value: function getLowerBound() {
      return this.state.bounds[0];
    }
  }, {
    key: "getUpperBound",
    value: function getUpperBound() {
      var bounds = this.state.bounds;
      return bounds[bounds.length - 1];
    }
    /**
     * Returns an array of possible slider points, taking into account both
     * `marks` and `step`. The result is cached.
     */

  }, {
    key: "getPoints",
    value: function getPoints() {
      var _this$props = this.props,
          marks = _this$props.marks,
          step = _this$props.step,
          min = _this$props.min,
          max = _this$props.max;
      var cache = this._getPointsCache;

      if (!cache || cache.marks !== marks || cache.step !== step) {
        var pointsObject = (0, _objectSpread2["default"])({}, marks);

        if (step !== null) {
          for (var point = min; point <= max; point += step) {
            pointsObject[point] = point;
          }
        }

        var points = Object.keys(pointsObject).map(parseFloat);
        points.sort(function (a, b) {
          return a - b;
        });
        this._getPointsCache = {
          marks: marks,
          step: step,
          points: points
        };
      }

      return this._getPointsCache.points;
    }
  }, {
    key: "moveTo",
    value: function moveTo(value, isFromKeyboardEvent) {
      var _this3 = this;

      var state = this.state,
          props = this.props;
      var nextBounds = (0, _toConsumableArray2["default"])(state.bounds);
      nextBounds[state.handle] = value;
      var nextHandle = state.handle;

      if (props.pushable !== false) {
        this.pushSurroundingHandles(nextBounds, nextHandle);
      } else if (props.allowCross) {
        nextBounds.sort(function (a, b) {
          return a - b;
        });
        nextHandle = nextBounds.indexOf(value);
      }

      this.onChange({
        handle: nextHandle,
        bounds: nextBounds
      });

      if (isFromKeyboardEvent) {
        // known problem: because setState is async,
        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,
        // cause onBeforeChange and onAfterChange receive wrong value.
        // here use setState callback to hackï¼Œbut not elegant
        this.setState({}, function () {
          _this3.handlesRefs[nextHandle].focus();
        });
      }
    }
  }, {
    key: "pushSurroundingHandles",
    value: function pushSurroundingHandles(bounds, handle) {
      var value = bounds[handle];
      var threshold = this.props.pushable;
      threshold = Number(threshold);
      var direction = 0;

      if (bounds[handle + 1] - value < threshold) {
        direction = +1; // push to right
      }

      if (value - bounds[handle - 1] < threshold) {
        direction = -1; // push to left
      }

      if (direction === 0) {
        return;
      }

      var nextHandle = handle + direction;
      var diffToNext = direction * (bounds[nextHandle] - value);

      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        // revert to original value if pushing is impossible
        bounds[handle] = bounds[nextHandle] - direction * threshold;
      }
    }
  }, {
    key: "pushHandle",
    value: function pushHandle(bounds, handle, direction, amount) {
      var originalValue = bounds[handle];
      var currentValue = bounds[handle];

      while (direction * (currentValue - originalValue) < amount) {
        if (!this.pushHandleOnePoint(bounds, handle, direction)) {
          // can't push handle enough to create the needed `amount` gap, so we
          // revert its position to the original value
          bounds[handle] = originalValue;
          return false;
        }

        currentValue = bounds[handle];
      } // the handle was pushed enough to create the needed `amount` gap


      return true;
    }
  }, {
    key: "pushHandleOnePoint",
    value: function pushHandleOnePoint(bounds, handle, direction) {
      var points = this.getPoints();
      var pointIndex = points.indexOf(bounds[handle]);
      var nextPointIndex = pointIndex + direction;

      if (nextPointIndex >= points.length || nextPointIndex < 0) {
        // reached the minimum or maximum available point, can't push anymore
        return false;
      }

      var nextHandle = handle + direction;
      var nextValue = points[nextPointIndex];
      var threshold = this.props.pushable;
      var diffToNext = direction * (bounds[nextHandle] - nextValue);

      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        // couldn't push next handle, so we won't push this one either
        return false;
      } // push the handle


      bounds[handle] = nextValue;
      return true;
    }
  }, {
    key: "trimAlignValue",
    value: function trimAlignValue(v, handle) {
      var nextProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var mergedProps = (0, _objectSpread2["default"])({}, this.props, {}, nextProps);
      var valInRange = utils.ensureValueInRange(v, mergedProps);
      var valNotConflict = this.ensureValueNotConflict(handle, valInRange, mergedProps);
      return utils.ensureValuePrecision(valNotConflict, mergedProps);
    }
  }, {
    key: "ensureValueNotConflict",
    value: function ensureValueNotConflict(handle, val, _ref) {
      var allowCross = _ref.allowCross,
          thershold = _ref.pushable;
      var state = this.state || {};
      var bounds = state.bounds;
      handle = handle === undefined ? state.handle : handle;
      thershold = Number(thershold);
      /* eslint-disable eqeqeq */

      if (!allowCross && handle != null && bounds !== undefined) {
        if (handle > 0 && val <= bounds[handle - 1] + thershold) {
          return bounds[handle - 1] + thershold;
        }

        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {
          return bounds[handle + 1] - thershold;
        }
      }
      /* eslint-enable eqeqeq */


      return val;
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$state2 = this.state,
          handle = _this$state2.handle,
          bounds = _this$state2.bounds;
      var _this$props2 = this.props,
          prefixCls = _this$props2.prefixCls,
          vertical = _this$props2.vertical,
          included = _this$props2.included,
          disabled = _this$props2.disabled,
          min = _this$props2.min,
          max = _this$props2.max,
          handleGenerator = _this$props2.handle,
          trackStyle = _this$props2.trackStyle,
          handleStyle = _this$props2.handleStyle,
          tabIndex = _this$props2.tabIndex;
      var offsets = bounds.map(function (v) {
        return _this4.calcOffset(v);
      });
      var handleClassName = "".concat(prefixCls, "-handle");
      var handles = bounds.map(function (v, i) {
        var _classNames;

        return handleGenerator({
          className: (0, _classnames["default"])((_classNames = {}, (0, _defineProperty2["default"])(_classNames, handleClassName, true), (0, _defineProperty2["default"])(_classNames, "".concat(handleClassName, "-").concat(i + 1), true), _classNames)),
          prefixCls: prefixCls,
          vertical: vertical,
          offset: offsets[i],
          value: v,
          dragging: handle === i,
          index: i,
          tabIndex: tabIndex[i] || 0,
          min: min,
          max: max,
          disabled: disabled,
          style: handleStyle[i],
          ref: function ref(h) {
            return _this4.saveHandle(i, h);
          }
        });
      });
      var tracks = bounds.slice(0, -1).map(function (_, index) {
        var _classNames2;

        var i = index + 1;
        var trackClassName = (0, _classnames["default"])((_classNames2 = {}, (0, _defineProperty2["default"])(_classNames2, "".concat(prefixCls, "-track"), true), (0, _defineProperty2["default"])(_classNames2, "".concat(prefixCls, "-track-").concat(i), true), _classNames2));
        return _react["default"].createElement(_Track["default"], {
          className: trackClassName,
          vertical: vertical,
          included: included,
          offset: offsets[i - 1],
          length: offsets[i] - offsets[i - 1],
          style: trackStyle[index],
          key: i
        });
      });
      return {
        tracks: tracks,
        handles: handles
      };
    }
  }]);
  return Range;
}(_react.Component);

(0, _defineProperty2["default"])(Range, "displayName", 'Range');
(0, _defineProperty2["default"])(Range, "propTypes", {
  defaultValue: _propTypes["default"].arrayOf(_propTypes["default"].number),
  value: _propTypes["default"].arrayOf(_propTypes["default"].number),
  count: _propTypes["default"].number,
  pushable: _propTypes["default"].oneOfType([_propTypes["default"].bool, _propTypes["default"].number]),
  allowCross: _propTypes["default"].bool,
  disabled: _propTypes["default"].bool,
  tabIndex: _propTypes["default"].arrayOf(_propTypes["default"].number)
});
(0, _defineProperty2["default"])(Range, "defaultProps", {
  count: 1,
  allowCross: true,
  pushable: false,
  tabIndex: []
});

var _default = (0, _createSlider["default"])(Range);

exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJhbmdlLmpzeCJdLCJuYW1lcyI6WyJSYW5nZSIsInByb3BzIiwicmVtb3ZlRG9jdW1lbnRFdmVudHMiLCJvbkFmdGVyQ2hhbmdlIiwiZ2V0VmFsdWUiLCJjb3VudCIsIm1pbiIsIm1heCIsImluaXRpYWxWYWx1ZSIsIkFycmF5IiwiYXBwbHkiLCJtYXAiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImJvdW5kcyIsInYiLCJpIiwidHJpbUFsaWduVmFsdWUiLCJyZWNlbnQiLCJsZW5ndGgiLCJzdGF0ZSIsImhhbmRsZSIsIm5leHRQcm9wcyIsIm5leHRCb3VuZHMiLCJldmVyeSIsInNldFN0YXRlIiwic29tZSIsInV0aWxzIiwiaXNWYWx1ZU91dE9mUmFuZ2UiLCJuZXdWYWx1ZXMiLCJlbnN1cmVWYWx1ZUluUmFuZ2UiLCJvbkNoYW5nZSIsImlzTm90Q29udHJvbGxlZCIsImRhdGEiLCJjaGFuZ2VkVmFsdWUiLCJwb3NpdGlvbiIsIm9uQmVmb3JlQ2hhbmdlIiwiY2FsY1ZhbHVlQnlQb3MiLCJzdGFydFZhbHVlIiwic3RhcnRQb3NpdGlvbiIsImNsb3Nlc3RCb3VuZCIsImdldENsb3Nlc3RCb3VuZCIsInByZXZNb3ZlZEhhbmRsZUluZGV4IiwiZ2V0Qm91bmROZWVkTW92aW5nIiwicHJldlZhbHVlIiwiZSIsInBhdXNlRXZlbnQiLCJvbGRWYWx1ZSIsIm1vdmVUbyIsInZhbHVlTXV0YXRvciIsImdldEtleWJvYXJkVmFsdWVNdXRhdG9yIiwibXV0YXRlZFZhbHVlIiwiaXNGcm9tS2V5Ym9hcmRFdmVudCIsIk1hdGgiLCJhYnMiLCJib3VuZE5lZWRNb3ZpbmciLCJpc0F0VGhlU2FtZVBvaW50IiwibWFya3MiLCJzdGVwIiwiY2FjaGUiLCJfZ2V0UG9pbnRzQ2FjaGUiLCJwb2ludHNPYmplY3QiLCJwb2ludCIsInBvaW50cyIsIk9iamVjdCIsImtleXMiLCJwYXJzZUZsb2F0Iiwic29ydCIsImEiLCJiIiwibmV4dEhhbmRsZSIsInB1c2hhYmxlIiwicHVzaFN1cnJvdW5kaW5nSGFuZGxlcyIsImFsbG93Q3Jvc3MiLCJpbmRleE9mIiwiaGFuZGxlc1JlZnMiLCJmb2N1cyIsInRocmVzaG9sZCIsIk51bWJlciIsImRpcmVjdGlvbiIsImRpZmZUb05leHQiLCJwdXNoSGFuZGxlIiwiYW1vdW50Iiwib3JpZ2luYWxWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsInB1c2hIYW5kbGVPbmVQb2ludCIsImdldFBvaW50cyIsInBvaW50SW5kZXgiLCJuZXh0UG9pbnRJbmRleCIsIm5leHRWYWx1ZSIsIm1lcmdlZFByb3BzIiwidmFsSW5SYW5nZSIsInZhbE5vdENvbmZsaWN0IiwiZW5zdXJlVmFsdWVOb3RDb25mbGljdCIsImVuc3VyZVZhbHVlUHJlY2lzaW9uIiwidmFsIiwidGhlcnNob2xkIiwicHJlZml4Q2xzIiwidmVydGljYWwiLCJpbmNsdWRlZCIsImRpc2FibGVkIiwiaGFuZGxlR2VuZXJhdG9yIiwidHJhY2tTdHlsZSIsImhhbmRsZVN0eWxlIiwidGFiSW5kZXgiLCJvZmZzZXRzIiwiY2FsY09mZnNldCIsImhhbmRsZUNsYXNzTmFtZSIsImhhbmRsZXMiLCJjbGFzc05hbWUiLCJvZmZzZXQiLCJkcmFnZ2luZyIsImluZGV4Iiwic3R5bGUiLCJyZWYiLCJoIiwic2F2ZUhhbmRsZSIsInRyYWNrcyIsInNsaWNlIiwiXyIsInRyYWNrQ2xhc3NOYW1lIiwiQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiYXJyYXlPZiIsIm51bWJlciIsIm9uZU9mVHlwZSIsImJvb2wiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBUEE7SUFTTUEsSzs7Ozs7QUFzQkosaUJBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFBQTtBQUNqQixpSEFBTUEsS0FBTjtBQURpQiw4RkFtRlgsWUFBTTtBQUNaLFlBQUtDLG9CQUFMOztBQUNBLFlBQUtELEtBQUwsQ0FBV0UsYUFBWCxD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VUFBQSxLQUFLLEVBQUVzRixVQUFVLENBQUNVLEtBQUQsQ0FObkI7QUFPRSxVQUFBLEdBQUcsRUFBRWhHO0FBUFAsVUFERjtBQVdELE9BakJjLENBQWY7QUFtQkEsYUFBTztBQUFFcUcsUUFBQUEsTUFBTSxFQUFOQSxNQUFGO0FBQVVULFFBQUFBLE9BQU8sRUFBUEE7QUFBVixPQUFQO0FBQ0Q7OztFQWpYaUJhLGdCOztpQ0FBZDFILEssaUJBQ2lCLE87aUNBRGpCQSxLLGVBRWU7QUFDakJZLEVBQUFBLFlBQVksRUFBRStHLHNCQUFVQyxPQUFWLENBQWtCRCxzQkFBVUUsTUFBNUIsQ0FERztBQUVqQmhILEVBQUFBLEtBQUssRUFBRThHLHNCQUFVQyxPQUFWLENBQWtCRCxzQkFBVUUsTUFBNUIsQ0FGVTtBQUdqQnhILEVBQUFBLEtBQUssRUFBRXNILHNCQUFVRSxNQUhBO0FBSWpCckQsRUFBQUEsUUFBUSxFQUFFbUQsc0JBQVVHLFNBQVYsQ0FBb0IsQ0FDNUJILHNCQUFVSSxJQURrQixFQUU1Qkosc0JBQVVFLE1BRmtCLENBQXBCLENBSk87QUFRakJuRCxFQUFBQSxVQUFVLEVBQUVpRCxzQkFBVUksSUFSTDtBQVNqQjFCLEVBQUFBLFFBQVEsRUFBRXNCLHNCQUFVSSxJQVRIO0FBVWpCdEIsRUFBQUEsUUFBUSxFQUFFa0Isc0JBQVVDLE9BQVYsQ0FBa0JELHNCQUFVRSxNQUE1QjtBQVZPLEM7aUNBRmY3SCxLLGtCQWVrQjtBQUNwQkssRUFBQUEsS0FBSyxFQUFFLENBRGE7QUFFcEJxRSxFQUFBQSxVQUFVLEVBQUUsSUFGUTtBQUdwQkYsRUFBQUEsUUFBUSxFQUFFLEtBSFU7QUFJcEJpQyxFQUFBQSxRQUFRLEVBQUU7QUFKVSxDOztlQXFXVCw4QkFBYXpHLEtBQWIsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3Byb3AtdHlwZXMgKi9cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJ2xvZGFzaC9pc0VxdWFsJztcbmltcG9ydCBUcmFjayBmcm9tICcuL2NvbW1vbi9UcmFjayc7XG5pbXBvcnQgY3JlYXRlU2xpZGVyIGZyb20gJy4vY29tbW9uL2NyZWF0ZVNsaWRlcic7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuY2xhc3MgUmFuZ2UgZXh0ZW5kcyBDb21wb25lbnQge1xuICBzdGF0aWMgZGlzcGxheU5hbWUgPSAnUmFuZ2UnO1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksXG4gICAgdmFsdWU6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5udW1iZXIpLFxuICAgIGNvdW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHB1c2hhYmxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5ib29sLFxuICAgICAgUHJvcFR5cGVzLm51bWJlcixcbiAgICBdKSxcbiAgICBhbGxvd0Nyb3NzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgdGFiSW5kZXg6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5udW1iZXIpLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgY291bnQ6IDEsXG4gICAgYWxsb3dDcm9zczogdHJ1ZSxcbiAgICBwdXNoYWJsZTogZmFsc2UsXG4gICAgdGFiSW5kZXg6IFtdLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgY29uc3QgeyBjb3VudCwgbWluLCBtYXggfSA9IHByb3BzO1xuICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KGNvdW50ICsgMSkpXG4gICAgICAgICAgICAubWFwKCgpID0+IG1pbik7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gJ2RlZmF1bHRWYWx1ZScgaW4gcHJvcHMgP1xuICAgICAgICAgICAgcHJvcHMuZGVmYXVsdFZhbHVlIDogaW5pdGlhbFZhbHVlO1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbiAgICBjb25zdCBib3VuZHMgPSB2YWx1ZS5tYXAoKHYsIGkpID0+IHRoaXMudHJpbUFsaWduVmFsdWUodiwgaSkpO1xuICAgIGNvbnN0IHJlY2VudCA9IGJvdW5kc1swXSA9PT0gbWF4ID8gMCA6IGJvdW5kcy5sZW5ndGggLSAxO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhhbmRsZTogbnVsbCxcbiAgICAgIHJlY2VudCxcbiAgICAgIGJvdW5kcyxcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAoISgndmFsdWUnIGluIG5leHRQcm9wcyB8fCAnbWluJyBpbiBuZXh0UHJvcHMgfHwgJ21heCcgaW4gbmV4dFByb3BzKSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnByb3BzLm1pbiA9PT0gbmV4dFByb3BzLm1pbiAmJlxuICAgICAgICB0aGlzLnByb3BzLm1heCA9PT0gbmV4dFByb3BzLm1heCAmJlxuICAgICAgICBzaGFsbG93RXF1YWwodGhpcy5wcm9wcy52YWx1ZSwgbmV4dFByb3BzLnZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgYm91bmRzIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHZhbHVlID0gbmV4dFByb3BzLnZhbHVlIHx8IGJvdW5kcztcbiAgICBjb25zdCBuZXh0Qm91bmRzID0gdmFsdWUubWFwKCh2LCBpKSA9PiB0aGlzLnRyaW1BbGlnblZhbHVlKHYsIGksIG5leHRQcm9wcykpO1xuICAgIGlmIChuZXh0Qm91bmRzLmxlbmd0aCA9PT0gYm91bmRzLmxlbmd0aCAmJiBuZXh0Qm91bmRzLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBib3VuZHNbaV0pKSByZXR1cm47XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgYm91bmRzOiBuZXh0Qm91bmRzIH0pO1xuXG4gICAgaWYgKGJvdW5kcy5zb21lKHYgPT4gdXRpbHMuaXNWYWx1ZU91dE9mUmFuZ2UodiwgbmV4dFByb3BzKSkpIHtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlcyA9IHZhbHVlLm1hcCgodikgPT4ge1xuICAgICAgICByZXR1cm4gdXRpbHMuZW5zdXJlVmFsdWVJblJhbmdlKHYsIG5leHRQcm9wcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UobmV3VmFsdWVzKTtcbiAgICB9XG4gIH1cblxuICBvbkNoYW5nZShzdGF0ZSkge1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBpc05vdENvbnRyb2xsZWQgPSAhKCd2YWx1ZScgaW4gcHJvcHMpO1xuICAgIGlmIChpc05vdENvbnRyb2xsZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuaGFuZGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBoYW5kbGU6IHN0YXRlLmhhbmRsZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0geyAuLi50aGlzLnN0YXRlLCAuLi5zdGF0ZSB9O1xuICAgIGNvbnN0IGNoYW5nZWRWYWx1ZSA9IGRhdGEuYm91bmRzO1xuICAgIHByb3BzLm9uQ2hhbmdlKGNoYW5nZWRWYWx1ZSk7XG4gIH1cblxuICBvblN0YXJ0KHBvc2l0aW9uKSB7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgcHJvcHMub25CZWZvcmVDaGFuZ2UoYm91bmRzKTtcblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jYWxjVmFsdWVCeVBvcyhwb3NpdGlvbik7XG4gICAgdGhpcy5zdGFydFZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gcG9zaXRpb247XG5cbiAgICBjb25zdCBjbG9zZXN0Qm91bmQgPSB0aGlzLmdldENsb3Nlc3RCb3VuZCh2YWx1ZSk7XG4gICAgdGhpcy5wcmV2TW92ZWRIYW5kbGVJbmRleCA9IHRoaXMuZ2V0Qm91bmROZWVkTW92aW5nKHZhbHVlLCBjbG9zZXN0Qm91bmQpO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBoYW5kbGU6IHRoaXMucHJldk1vdmVkSGFuZGxlSW5kZXgsXG4gICAgICByZWNlbnQ6IHRoaXMucHJldk1vdmVkSGFuZGxlSW5kZXgsXG4gICAgfSk7XG5cbiAgICBjb25zdCBwcmV2VmFsdWUgPSBib3VuZHNbdGhpcy5wcmV2TW92ZWRIYW5kbGVJbmRleF07XG4gICAgaWYgKHZhbHVlID09PSBwcmV2VmFsdWUpIHJldHVybjtcblxuICAgIGNvbnN0IG5leHRCb3VuZHMgPSBbLi4uc3RhdGUuYm91bmRzXTtcbiAgICBuZXh0Qm91bmRzW3RoaXMucHJldk1vdmVkSGFuZGxlSW5kZXhdID0gdmFsdWU7XG4gICAgdGhpcy5vbkNoYW5nZSh7IGJvdW5kczogbmV4dEJvdW5kcyB9KTtcbiAgfVxuXG4gIG9uRW5kID0gKCkgPT4ge1xuICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRFdmVudHMoKTtcbiAgICB0aGlzLnByb3BzLm9uQWZ0ZXJDaGFuZ2UodGhpcy5nZXRWYWx1ZSgpKTtcbiAgfVxuXG4gIG9uTW92ZShlLCBwb3NpdGlvbikge1xuICAgIHV0aWxzLnBhdXNlRXZlbnQoZSk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmNhbGNWYWx1ZUJ5UG9zKHBvc2l0aW9uKTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHN0YXRlLmJvdW5kc1tzdGF0ZS5oYW5kbGVdO1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHJldHVybjtcblxuICAgIHRoaXMubW92ZVRvKHZhbHVlKTtcbiAgfVxuXG4gIG9uS2V5Ym9hcmQoZSkge1xuICAgIGNvbnN0IHZhbHVlTXV0YXRvciA9IHV0aWxzLmdldEtleWJvYXJkVmFsdWVNdXRhdG9yKGUpO1xuXG4gICAgaWYgKHZhbHVlTXV0YXRvcikge1xuICAgICAgdXRpbHMucGF1c2VFdmVudChlKTtcbiAgICAgIGNvbnN0IHsgc3RhdGUsIHByb3BzIH0gPSB0aGlzO1xuICAgICAgY29uc3QgeyBib3VuZHMsIGhhbmRsZSB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IGJvdW5kc1toYW5kbGVdO1xuICAgICAgY29uc3QgbXV0YXRlZFZhbHVlID0gdmFsdWVNdXRhdG9yKG9sZFZhbHVlLCBwcm9wcyk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudHJpbUFsaWduVmFsdWUobXV0YXRlZFZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHJldHVybjtcbiAgICAgIGNvbnN0IGlzRnJvbUtleWJvYXJkRXZlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5tb3ZlVG8odmFsdWUsIGlzRnJvbUtleWJvYXJkRXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmJvdW5kcztcbiAgfVxuXG4gIGdldENsb3Nlc3RCb3VuZCh2YWx1ZSkge1xuICAgIGNvbnN0IHsgYm91bmRzIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBjbG9zZXN0Qm91bmQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYm91bmRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgaWYgKHZhbHVlID4gYm91bmRzW2ldKSB7IGNsb3Nlc3RCb3VuZCA9IGk7IH1cbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKGJvdW5kc1tjbG9zZXN0Qm91bmQgKyAxXSAtIHZhbHVlKSA8IE1hdGguYWJzKGJvdW5kc1tjbG9zZXN0Qm91bmRdIC0gdmFsdWUpKSB7XG4gICAgICBjbG9zZXN0Qm91bmQgPSBjbG9zZXN0Qm91bmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdEJvdW5kO1xuICB9XG5cbiAgZ2V0Qm91bmROZWVkTW92aW5nKHZhbHVlLCBjbG9zZXN0Qm91bmQpIHtcbiAgICBjb25zdCB7IGJvdW5kcywgcmVjZW50IH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBib3VuZE5lZWRNb3ZpbmcgPSBjbG9zZXN0Qm91bmQ7XG4gICAgY29uc3QgaXNBdFRoZVNhbWVQb2ludCA9IChib3VuZHNbY2xvc2VzdEJvdW5kICsgMV0gPT09IGJvdW5kc1tjbG9zZXN0Qm91bmRdKTtcblxuICAgIGlmIChpc0F0VGhlU2FtZVBvaW50ICYmIGJvdW5kc1tyZWNlbnRdID09PSBib3VuZHNbY2xvc2VzdEJvdW5kXSkge1xuICAgICAgYm91bmROZWVkTW92aW5nID0gcmVjZW50O1xuICAgIH1cblxuICAgIGlmIChpc0F0VGhlU2FtZVBvaW50ICYmICh2YWx1ZSAhPT0gYm91bmRzW2Nsb3Nlc3RCb3VuZCArIDFdKSkge1xuICAgICAgYm91bmROZWVkTW92aW5nID0gdmFsdWUgPCBib3VuZHNbY2xvc2VzdEJvdW5kICsgMV0gPyBjbG9zZXN0Qm91bmQgOiBjbG9zZXN0Qm91bmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gYm91bmROZWVkTW92aW5nO1xuICB9XG5cbiAgZ2V0TG93ZXJCb3VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5ib3VuZHNbMF07XG4gIH1cblxuICBnZXRVcHBlckJvdW5kKCkge1xuICAgIGNvbnN0IHsgYm91bmRzIH0gPSB0aGlzLnN0YXRlO1xuICAgIHJldHVybiBib3VuZHNbYm91bmRzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcG9zc2libGUgc2xpZGVyIHBvaW50cywgdGFraW5nIGludG8gYWNjb3VudCBib3RoXG4gICAqIGBtYXJrc2AgYW5kIGBzdGVwYC4gVGhlIHJlc3VsdCBpcyBjYWNoZWQuXG4gICAqL1xuICBnZXRQb2ludHMoKSB7XG4gICAgY29uc3QgeyBtYXJrcywgc3RlcCwgbWluLCBtYXggfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9nZXRQb2ludHNDYWNoZTtcbiAgICBpZiAoIWNhY2hlIHx8IGNhY2hlLm1hcmtzICE9PSBtYXJrcyB8fCBjYWNoZS5zdGVwICE9PSBzdGVwKSB7XG4gICAgICBjb25zdCBwb2ludHNPYmplY3QgPSB7IC4uLm1hcmtzIH07XG4gICAgICBpZiAoc3RlcCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBwb2ludCA9IG1pbjsgcG9pbnQgPD0gbWF4OyBwb2ludCArPSBzdGVwKSB7XG4gICAgICAgICAgcG9pbnRzT2JqZWN0W3BvaW50XSA9IHBvaW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwb2ludHMgPSBPYmplY3Qua2V5cyhwb2ludHNPYmplY3QpLm1hcChwYXJzZUZsb2F0KTtcbiAgICAgIHBvaW50cy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICB0aGlzLl9nZXRQb2ludHNDYWNoZSA9IHsgbWFya3MsIHN0ZXAsIHBvaW50cyB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ2V0UG9pbnRzQ2FjaGUucG9pbnRzO1xuICB9XG5cbiAgbW92ZVRvKHZhbHVlLCBpc0Zyb21LZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgeyBzdGF0ZSwgcHJvcHMgfSA9IHRoaXM7XG4gICAgY29uc3QgbmV4dEJvdW5kcyA9IFsuLi5zdGF0ZS5ib3VuZHNdO1xuICAgIG5leHRCb3VuZHNbc3RhdGUuaGFuZGxlXSA9IHZhbHVlO1xuICAgIGxldCBuZXh0SGFuZGxlID0gc3RhdGUuaGFuZGxlO1xuICAgIGlmIChwcm9wcy5wdXNoYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucHVzaFN1cnJvdW5kaW5nSGFuZGxlcyhuZXh0Qm91bmRzLCBuZXh0SGFuZGxlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BzLmFsbG93Q3Jvc3MpIHtcbiAgICAgIG5leHRCb3VuZHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgbmV4dEhhbmRsZSA9IG5leHRCb3VuZHMuaW5kZXhPZih2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMub25DaGFuZ2Uoe1xuICAgICAgaGFuZGxlOiBuZXh0SGFuZGxlLFxuICAgICAgYm91bmRzOiBuZXh0Qm91bmRzLFxuICAgIH0pO1xuICAgIGlmIChpc0Zyb21LZXlib2FyZEV2ZW50KSB7XG4gICAgICAvLyBrbm93biBwcm9ibGVtOiBiZWNhdXNlIHNldFN0YXRlIGlzIGFzeW5jLFxuICAgICAgLy8gc28gdHJpZ2dlciBmb2N1cyB3aWxsIGludm9rZSBoYW5kbGVyJ3Mgb25FbmQgYW5kIGFub3RoZXIgaGFuZGxlcidzIG9uU3RhcnQgdG9vIGVhcmx5LFxuICAgICAgLy8gY2F1c2Ugb25CZWZvcmVDaGFuZ2UgYW5kIG9uQWZ0ZXJDaGFuZ2UgcmVjZWl2ZSB3cm9uZyB2YWx1ZS5cbiAgICAgIC8vIGhlcmUgdXNlIHNldFN0YXRlIGNhbGxiYWNrIHRvIGhhY2vvvIxidXQgbm90IGVsZWdhbnRcbiAgICAgIHRoaXMuc2V0U3RhdGUoe30sICgpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVzUmVmc1tuZXh0SGFuZGxlXS5mb2N1cygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVzaFN1cnJvdW5kaW5nSGFuZGxlcyhib3VuZHMsIGhhbmRsZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYm91bmRzW2hhbmRsZV07XG4gICAgbGV0IHsgcHVzaGFibGU6IHRocmVzaG9sZCB9ID0gdGhpcy5wcm9wcztcbiAgICB0aHJlc2hvbGQgPSBOdW1iZXIodGhyZXNob2xkKTtcblxuICAgIGxldCBkaXJlY3Rpb24gPSAwO1xuICAgIGlmIChib3VuZHNbaGFuZGxlICsgMV0gLSB2YWx1ZSA8IHRocmVzaG9sZCkge1xuICAgICAgZGlyZWN0aW9uID0gKzE7IC8vIHB1c2ggdG8gcmlnaHRcbiAgICB9XG4gICAgaWYgKHZhbHVlIC0gYm91bmRzW2hhbmRsZSAtIDFdIDwgdGhyZXNob2xkKSB7XG4gICAgICBkaXJlY3Rpb24gPSAtMTsgLy8gcHVzaCB0byBsZWZ0XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgIGNvbnN0IG5leHRIYW5kbGUgPSBoYW5kbGUgKyBkaXJlY3Rpb247XG4gICAgY29uc3QgZGlmZlRvTmV4dCA9IGRpcmVjdGlvbiAqIChib3VuZHNbbmV4dEhhbmRsZV0gLSB2YWx1ZSk7XG4gICAgaWYgKCF0aGlzLnB1c2hIYW5kbGUoYm91bmRzLCBuZXh0SGFuZGxlLCBkaXJlY3Rpb24sIHRocmVzaG9sZCAtIGRpZmZUb05leHQpKSB7XG4gICAgICAvLyByZXZlcnQgdG8gb3JpZ2luYWwgdmFsdWUgaWYgcHVzaGluZyBpcyBpbXBvc3NpYmxlXG4gICAgICBib3VuZHNbaGFuZGxlXSA9IGJvdW5kc1tuZXh0SGFuZGxlXSAtIChkaXJlY3Rpb24gKiB0aHJlc2hvbGQpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hIYW5kbGUoYm91bmRzLCBoYW5kbGUsIGRpcmVjdGlvbiwgYW1vdW50KSB7XG4gICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IGJvdW5kc1toYW5kbGVdO1xuICAgIGxldCBjdXJyZW50VmFsdWUgPSBib3VuZHNbaGFuZGxlXTtcbiAgICB3aGlsZSAoZGlyZWN0aW9uICogKGN1cnJlbnRWYWx1ZSAtIG9yaWdpbmFsVmFsdWUpIDwgYW1vdW50KSB7XG4gICAgICBpZiAoIXRoaXMucHVzaEhhbmRsZU9uZVBvaW50KGJvdW5kcywgaGFuZGxlLCBkaXJlY3Rpb24pKSB7XG4gICAgICAgIC8vIGNhbid0IHB1c2ggaGFuZGxlIGVub3VnaCB0byBjcmVhdGUgdGhlIG5lZWRlZCBgYW1vdW50YCBnYXAsIHNvIHdlXG4gICAgICAgIC8vIHJldmVydCBpdHMgcG9zaXRpb24gdG8gdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgIGJvdW5kc1toYW5kbGVdID0gb3JpZ2luYWxWYWx1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY3VycmVudFZhbHVlID0gYm91bmRzW2hhbmRsZV07XG4gICAgfVxuICAgIC8vIHRoZSBoYW5kbGUgd2FzIHB1c2hlZCBlbm91Z2ggdG8gY3JlYXRlIHRoZSBuZWVkZWQgYGFtb3VudGAgZ2FwXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdXNoSGFuZGxlT25lUG9pbnQoYm91bmRzLCBoYW5kbGUsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XG4gICAgY29uc3QgcG9pbnRJbmRleCA9IHBvaW50cy5pbmRleE9mKGJvdW5kc1toYW5kbGVdKTtcbiAgICBjb25zdCBuZXh0UG9pbnRJbmRleCA9IHBvaW50SW5kZXggKyBkaXJlY3Rpb247XG4gICAgaWYgKG5leHRQb2ludEluZGV4ID49IHBvaW50cy5sZW5ndGggfHwgbmV4dFBvaW50SW5kZXggPCAwKSB7XG4gICAgICAvLyByZWFjaGVkIHRoZSBtaW5pbXVtIG9yIG1heGltdW0gYXZhaWxhYmxlIHBvaW50LCBjYW4ndCBwdXNoIGFueW1vcmVcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbmV4dEhhbmRsZSA9IGhhbmRsZSArIGRpcmVjdGlvbjtcbiAgICBjb25zdCBuZXh0VmFsdWUgPSBwb2ludHNbbmV4dFBvaW50SW5kZXhdO1xuICAgIGNvbnN0IHsgcHVzaGFibGU6IHRocmVzaG9sZCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBkaWZmVG9OZXh0ID0gZGlyZWN0aW9uICogKGJvdW5kc1tuZXh0SGFuZGxlXSAtIG5leHRWYWx1ZSk7XG4gICAgaWYgKCF0aGlzLnB1c2hIYW5kbGUoYm91bmRzLCBuZXh0SGFuZGxlLCBkaXJlY3Rpb24sIHRocmVzaG9sZCAtIGRpZmZUb05leHQpKSB7XG4gICAgICAvLyBjb3VsZG4ndCBwdXNoIG5leHQgaGFuZGxlLCBzbyB3ZSB3b24ndCBwdXNoIHRoaXMgb25lIGVpdGhlclxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBwdXNoIHRoZSBoYW5kbGVcbiAgICBib3VuZHNbaGFuZGxlXSA9IG5leHRWYWx1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyaW1BbGlnblZhbHVlKHYsIGhhbmRsZSwgbmV4dFByb3BzID0ge30pIHtcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IHsgLi4udGhpcy5wcm9wcywgLi4ubmV4dFByb3BzIH07XG4gICAgY29uc3QgdmFsSW5SYW5nZSA9IHV0aWxzLmVuc3VyZVZhbHVlSW5SYW5nZSh2LCBtZXJnZWRQcm9wcyk7XG4gICAgY29uc3QgdmFsTm90Q29uZmxpY3QgPSB0aGlzLmVuc3VyZVZhbHVlTm90Q29uZmxpY3QoaGFuZGxlLCB2YWxJblJhbmdlLCBtZXJnZWRQcm9wcyk7XG4gICAgcmV0dXJuIHV0aWxzLmVuc3VyZVZhbHVlUHJlY2lzaW9uKHZhbE5vdENvbmZsaWN0LCBtZXJnZWRQcm9wcyk7XG4gIH1cblxuICBlbnN1cmVWYWx1ZU5vdENvbmZsaWN0KGhhbmRsZSwgdmFsLCB7IGFsbG93Q3Jvc3MsIHB1c2hhYmxlOiB0aGVyc2hvbGQgfSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZSB8fCB7fTtcbiAgICBjb25zdCB7IGJvdW5kcyB9ID0gc3RhdGU7XG4gICAgaGFuZGxlID0gaGFuZGxlID09PSB1bmRlZmluZWQgPyBzdGF0ZS5oYW5kbGUgOiBoYW5kbGU7XG4gICAgdGhlcnNob2xkID0gTnVtYmVyKHRoZXJzaG9sZCk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gICAgaWYgKCFhbGxvd0Nyb3NzICYmIGhhbmRsZSAhPSBudWxsICYmIGJvdW5kcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaGFuZGxlID4gMCAmJiB2YWwgPD0gKGJvdW5kc1toYW5kbGUgLSAxXSArIHRoZXJzaG9sZCkpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kc1toYW5kbGUgLSAxXSArIHRoZXJzaG9sZDtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGUgPCBib3VuZHMubGVuZ3RoIC0gMSAmJiB2YWwgPj0gKGJvdW5kc1toYW5kbGUgKyAxXSAtIHRoZXJzaG9sZCkpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kc1toYW5kbGUgKyAxXSAtIHRoZXJzaG9sZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbmRsZSxcbiAgICAgIGJvdW5kcyxcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBwcmVmaXhDbHMsXG4gICAgICB2ZXJ0aWNhbCxcbiAgICAgIGluY2x1ZGVkLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBtaW4sXG4gICAgICBtYXgsXG4gICAgICBoYW5kbGU6IGhhbmRsZUdlbmVyYXRvcixcbiAgICAgIHRyYWNrU3R5bGUsXG4gICAgICBoYW5kbGVTdHlsZSxcbiAgICAgIHRhYkluZGV4LFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3Qgb2Zmc2V0cyA9IGJvdW5kcy5tYXAodiA9PiB0aGlzLmNhbGNPZmZzZXQodikpO1xuXG4gICAgY29uc3QgaGFuZGxlQ2xhc3NOYW1lID0gYCR7cHJlZml4Q2xzfS1oYW5kbGVgO1xuICAgIGNvbnN0IGhhbmRsZXMgPSBib3VuZHMubWFwKCh2LCBpKSA9PiBoYW5kbGVHZW5lcmF0b3Ioe1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzKHtcbiAgICAgICAgW2hhbmRsZUNsYXNzTmFtZV06IHRydWUsXG4gICAgICAgIFtgJHtoYW5kbGVDbGFzc05hbWV9LSR7aSArIDF9YF06IHRydWUsXG4gICAgICB9KSxcbiAgICAgIHByZWZpeENscyxcbiAgICAgIHZlcnRpY2FsLFxuICAgICAgb2Zmc2V0OiBvZmZzZXRzW2ldLFxuICAgICAgdmFsdWU6IHYsXG4gICAgICBkcmFnZ2luZzogaGFuZGxlID09PSBpLFxuICAgICAgaW5kZXg6IGksXG4gICAgICB0YWJJbmRleDogdGFiSW5kZXhbaV0gfHwgMCxcbiAgICAgIG1pbixcbiAgICAgIG1heCxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgc3R5bGU6IGhhbmRsZVN0eWxlW2ldLFxuICAgICAgcmVmOiBoID0+IHRoaXMuc2F2ZUhhbmRsZShpLCBoKSxcbiAgICB9KSk7XG5cbiAgICBjb25zdCB0cmFja3MgPSBib3VuZHMuc2xpY2UoMCwgLTEpLm1hcCgoXywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBpbmRleCArIDE7XG4gICAgICBjb25zdCB0cmFja0NsYXNzTmFtZSA9IGNsYXNzTmFtZXMoe1xuICAgICAgICBbYCR7cHJlZml4Q2xzfS10cmFja2BdOiB0cnVlLFxuICAgICAgICBbYCR7cHJlZml4Q2xzfS10cmFjay0ke2l9YF06IHRydWUsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxUcmFja1xuICAgICAgICAgIGNsYXNzTmFtZT17dHJhY2tDbGFzc05hbWV9XG4gICAgICAgICAgdmVydGljYWw9e3ZlcnRpY2FsfVxuICAgICAgICAgIGluY2x1ZGVkPXtpbmNsdWRlZH1cbiAgICAgICAgICBvZmZzZXQ9e29mZnNldHNbaSAtIDFdfVxuICAgICAgICAgIGxlbmd0aD17b2Zmc2V0c1tpXSAtIG9mZnNldHNbaSAtIDFdfVxuICAgICAgICAgIHN0eWxlPXt0cmFja1N0eWxlW2luZGV4XX1cbiAgICAgICAgICBrZXk9e2l9XG4gICAgICAgIC8+XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgdHJhY2tzLCBoYW5kbGVzIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU2xpZGVyKFJhbmdlKTtcbiJdfQ==