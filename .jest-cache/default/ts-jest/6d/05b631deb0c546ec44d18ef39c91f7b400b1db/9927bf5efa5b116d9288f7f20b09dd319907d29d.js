/**
 * Legacy code. Should avoid to use if you are new to import these code.
 */
import React from 'react';
import warning from '../../_util/warning';
// @ts-ignore
import TreeNode from './TreeNode';
const DRAG_SIDE_RANGE = 0.25;
const DRAG_MIN_GAP = 2;
export function arrDel(list, value) {
    const clone = list.slice();
    const index = clone.indexOf(value);
    if (index >= 0) {
        clone.splice(index, 1);
    }
    return clone;
}
export function arrAdd(list, value) {
    const clone = list.slice();
    if (clone.indexOf(value) === -1) {
        clone.push(value);
    }
    return clone;
}
export function posToArr(pos) {
    return pos.split('-');
}
export function getPosition(level, index) {
    return `${level}-${index}`;
}
export function isTreeNode(node) {
    return node && node.type && node.type.isTreeNode;
}
export function getDragNodesKeys(dragNodeKey, keyEntities) {
    const dragNodesKeys = [dragNodeKey];
    const entity = keyEntities[dragNodeKey];
    function dig(list = []) {
        list.forEach(({ key, children }) => {
            dragNodesKeys.push(key);
            dig(children);
        });
    }
    dig(entity.children);
    return dragNodesKeys;
}
// Only used when drag, not affect SSR.
export function calcDropPosition(event, treeNode) {
    const { clientY } = event;
    const { top, bottom, height } = treeNode.selectHandle.getBoundingClientRect();
    const des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);
    if (clientY <= top + des) {
        return -1;
    }
    if (clientY >= bottom - des) {
        return 1;
    }
    return 0;
}
/**
 * Return selectedKeys according with multiple prop
 * @param selectedKeys
 * @param props
 * @returns [string]
 */
export function calcSelectedKeys(selectedKeys, props) {
    if (!selectedKeys)
        return undefined;
    const { multiple } = props;
    if (multiple) {
        return selectedKeys.slice();
    }
    if (selectedKeys.length) {
        return [selectedKeys[0]];
    }
    return selectedKeys;
}
const internalProcessProps = (props) => props;
export function convertDataToTree(treeData, processor) {
    if (!treeData)
        return [];
    const { processProps = internalProcessProps } = processor || {};
    const list = Array.isArray(treeData) ? treeData : [treeData];
    return list.map(({ children, ...props }) => {
        const childrenNodes = convertDataToTree(children, processor);
        // @ts-ignore
        // eslint-disable-next-line react/jsx-key
        return React.createElement(TreeNode, Object.assign({}, processProps(props)), childrenNodes);
    });
}
/**
 * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style
 */
export function parseCheckedKeys(keys) {
    if (!keys) {
        return null;
    }
    // Convert keys to object format
    let keyProps;
    if (Array.isArray(keys)) {
        // [Legacy] Follow the api doc
        keyProps = {
            checkedKeys: keys,
            halfCheckedKeys: undefined,
        };
    }
    else if (typeof keys === 'object') {
        keyProps = {
            checkedKeys: keys.checked || undefined,
            halfCheckedKeys: keys.halfChecked || undefined,
        };
    }
    else {
        warning(false, '`checkedKeys` is not an array or an object');
        return null;
    }
    return keyProps;
}
/**
 * If user use `autoExpandParent` we should get the list of parent node
 * @param keyList
 * @param keyEntities
 */
export function conductExpandParent(keyList, keyEntities) {
    const expandedKeys = {};
    function conductUp(key) {
        if (expandedKeys[key])
            return;
        const entity = keyEntities[key];
        if (!entity)
            return;
        expandedKeys[key] = true;
        const { parent, node } = entity;
        if (node.disabled)
            return;
        if (parent) {
            conductUp(parent.key);
        }
    }
    (keyList || []).forEach(key => {
        conductUp(key);
    });
    return Object.keys(expandedKeys);
}
/**
 * Returns only the data- and aria- key/value pairs
 */
export function getDataAndAria(props) {
    const omitProps = {};
    Object.keys(props).forEach(key => {
        if (key.startsWith('data-') || key.startsWith('aria-')) {
            omitProps[key] = props[key];
        }
    });
    return omitProps;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2h1aWh1YXdrL0RvY3VtZW50cy9vcHQvY2hvZXJvZG9uLXVpL2NvbXBvbmVudHMvcmMtY29tcG9uZW50cy90cmVlL3V0aWwudHN4IiwibWFwcGluZ3MiOiJBQUFBOztHQUVHO0FBRUgsT0FBTyxLQUFLLE1BQU0sT0FBTyxDQUFDO0FBQzFCLE9BQU8sT0FBTyxNQUFNLHFCQUFxQixDQUFDO0FBQzFDLGFBQWE7QUFDYixPQUFPLFFBQTJCLE1BQU0sWUFBWSxDQUFDO0FBSXJELE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQztBQUM3QixNQUFNLFlBQVksR0FBRyxDQUFDLENBQUM7QUFFdkIsTUFBTSxVQUFVLE1BQU0sQ0FBQyxJQUFXLEVBQUUsS0FBVTtJQUM1QyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDM0IsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNuQyxJQUFJLEtBQUssSUFBSSxDQUFDLEVBQUU7UUFDZCxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztLQUN4QjtJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVELE1BQU0sVUFBVSxNQUFNLENBQUMsSUFBVyxFQUFFLEtBQVU7SUFDNUMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQzNCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtRQUMvQixLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ25CO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQsTUFBTSxVQUFVLFFBQVEsQ0FBQyxHQUFXO0lBQ2xDLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN4QixDQUFDO0FBRUQsTUFBTSxVQUFVLFdBQVcsQ0FBQyxLQUFzQixFQUFFLEtBQWE7SUFDL0Qs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QUcsTUFBTSxDQUFDO1FBRWhDLElBQUksSUFBSSxDQUFDLFFBQVE7WUFBRSxPQUFPO1FBRTFCLElBQUksTUFBTSxFQUFFO1lBQ1YsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN2QjtJQUNILENBQUM7SUFFRCxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDNUIsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ25DLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sVUFBVSxjQUFjLENBQUMsS0FBeUM7SUFDdEUsTUFBTSxTQUFTLEdBQTJCLEVBQUUsQ0FBQztJQUM3QyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUMvQixJQUFJLEdBQUcsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN0RCxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzdCO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9odWlodWF3ay9Eb2N1bWVudHMvb3B0L2Nob2Vyb2Rvbi11aS9jb21wb25lbnRzL3JjLWNvbXBvbmVudHMvdHJlZS91dGlsLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExlZ2FjeSBjb2RlLiBTaG91bGQgYXZvaWQgdG8gdXNlIGlmIHlvdSBhcmUgbmV3IHRvIGltcG9ydCB0aGVzZSBjb2RlLlxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuLi8uLi9fdXRpbC93YXJuaW5nJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBUcmVlTm9kZSwgeyBUcmVlTm9kZVByb3BzIH0gZnJvbSAnLi9UcmVlTm9kZSc7XG5pbXBvcnQgeyBOb2RlRWxlbWVudCwgS2V5LCBEYXRhTm9kZSwgRW50aXR5LCBEYXRhRW50aXR5LCBOb2RlSW5zdGFuY2UgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmVlUHJvcHMgfSBmcm9tICcuL1RyZWUnO1xuXG5jb25zdCBEUkFHX1NJREVfUkFOR0UgPSAwLjI1O1xuY29uc3QgRFJBR19NSU5fR0FQID0gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFyckRlbChsaXN0OiBLZXlbXSwgdmFsdWU6IEtleSkge1xuICBjb25zdCBjbG9uZSA9IGxpc3Quc2xpY2UoKTtcbiAgY29uc3QgaW5kZXggPSBjbG9uZS5pbmRleE9mKHZhbHVlKTtcbiAgaWYgKGluZGV4ID49IDApIHtcbiAgICBjbG9uZS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyckFkZChsaXN0OiBLZXlbXSwgdmFsdWU6IEtleSkge1xuICBjb25zdCBjbG9uZSA9IGxpc3Quc2xpY2UoKTtcbiAgaWYgKGNsb25lLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgIGNsb25lLnB1c2godmFsdWUpO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvc1RvQXJyKHBvczogc3RyaW5nKSB7XG4gIHJldHVybiBwb3Muc3BsaXQoJy0nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBvc2l0aW9uKGxldmVsOiBzdHJpbmcgfCBudW1iZXIsIGluZGV4OiBudW1iZXIpIHtcbiAgcmV0dXJuIGAke2xldmVsfS0ke2luZGV4fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RyZWVOb2RlKG5vZGU6IE5vZGVFbGVtZW50KSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUudHlwZSAmJiBub2RlLnR5cGUuaXNUcmVlTm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERyYWdOb2Rlc0tleXMoZHJhZ05vZGVLZXk6IEtleSwga2V5RW50aXRpZXM6IFJlY29yZDxLZXksIERhdGFFbnRpdHk+KTogS2V5W10ge1xuICBjb25zdCBkcmFnTm9kZXNLZXlzID0gW2RyYWdOb2RlS2V5XTtcblxuICBjb25zdCBlbnRpdHkgPSBrZXlFbnRpdGllc1tkcmFnTm9kZUtleV07XG4gIGZ1bmN0aW9uIGRpZyhsaXN0OiBEYXRhRW50aXR5W10gPSBbXSkge1xuICAgIGxpc3QuZm9yRWFjaCgoeyBrZXksIGNoaWxkcmVuIH0pID0+IHtcbiAgICAgIGRyYWdOb2Rlc0tleXMucHVzaChrZXkpO1xuICAgICAgZGlnKGNoaWxkcmVuKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpZyhlbnRpdHkuY2hpbGRyZW4pO1xuXG4gIHJldHVybiBkcmFnTm9kZXNLZXlzO1xufVxuXG4vLyBPbmx5IHVzZWQgd2hlbiBkcmFnLCBub3QgYWZmZWN0IFNTUi5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjRHJvcFBvc2l0aW9uKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50LCB0cmVlTm9kZTogTm9kZUluc3RhbmNlKSB7XG4gIGNvbnN0IHsgY2xpZW50WSB9ID0gZXZlbnQ7XG4gIGNvbnN0IHsgdG9wLCBib3R0b20sIGhlaWdodCB9ID0gdHJlZU5vZGUuc2VsZWN0SGFuZGxlIS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZGVzID0gTWF0aC5tYXgoaGVpZ2h0ICogRFJBR19TSURFX1JBTkdFLCBEUkFHX01JTl9HQVApO1xuXG4gIGlmIChjbGllbnRZIDw9IHRvcCArIGRlcykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoY2xpZW50WSA+PSBib3R0b20gLSBkZXMpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIFJldHVybiBzZWxlY3RlZEtleXMgYWNjb3JkaW5nIHdpdGggbXVsdGlwbGUgcHJvcFxuICogQHBhcmFtIHNlbGVjdGVkS2V5c1xuICogQHBhcmFtIHByb3BzXG4gKiBAcmV0dXJucyBbc3RyaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY1NlbGVjdGVkS2V5cyhzZWxlY3RlZEtleXM6IEtleVtdLCBwcm9wczogVHJlZVByb3BzKSB7XG4gIGlmICghc2VsZWN0ZWRLZXlzKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHsgbXVsdGlwbGUgfSA9IHByb3BzO1xuICBpZiAobXVsdGlwbGUpIHtcbiAgICByZXR1cm4gc2VsZWN0ZWRLZXlzLnNsaWNlKCk7XG4gIH1cblxuICBpZiAoc2VsZWN0ZWRLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBbc2VsZWN0ZWRLZXlzWzBdXTtcbiAgfVxuICByZXR1cm4gc2VsZWN0ZWRLZXlzO1xufVxuXG5jb25zdCBpbnRlcm5hbFByb2Nlc3NQcm9wcyA9IChwcm9wczogRGF0YU5vZGUpOiBQYXJ0aWFsPFRyZWVOb2RlUHJvcHM+ID0+IHByb3BzO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREYXRhVG9UcmVlKFxuICB0cmVlRGF0YTogRGF0YU5vZGVbXSxcbiAgcHJvY2Vzc29yPzogeyBwcm9jZXNzUHJvcHM6IChwcm9wOiBEYXRhTm9kZSkgPT4gYW55IH0sXG4pOiBOb2RlRWxlbWVudFtdIHtcbiAgaWYgKCF0cmVlRGF0YSkgcmV0dXJuIFtdO1xuXG4gIGNvbnN0IHsgcHJvY2Vzc1Byb3BzID0gaW50ZXJuYWxQcm9jZXNzUHJvcHMgfSA9IHByb2Nlc3NvciB8fCB7fTtcbiAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkodHJlZURhdGEpID8gdHJlZURhdGEgOiBbdHJlZURhdGFdO1xuICByZXR1cm4gbGlzdC5tYXAoXG4gICAgKHsgY2hpbGRyZW4sIC4uLnByb3BzIH0pOiBOb2RlRWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBjaGlsZHJlbk5vZGVzID0gY29udmVydERhdGFUb1RyZWUoY2hpbGRyZW4hLCBwcm9jZXNzb3IpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1rZXlcbiAgICAgIHJldHVybiA8VHJlZU5vZGUgey4uLnByb2Nlc3NQcm9wcyhwcm9wcyl9PntjaGlsZHJlbk5vZGVzfTwvVHJlZU5vZGU+O1xuICAgIH0sXG4gICk7XG59XG5cbi8vIFRPRE86ID09PT09PT09PT09PT09PT09PT09PT09PT0gTkVXIExPR0lDID09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEB0cy1pZ25vcmVcbmludGVyZmFjZSBXcmFwcGVyIHtcbiAgcG9zRW50aXRpZXM6IFJlY29yZDxzdHJpbmcsIEVudGl0eT47XG4gIGtleUVudGl0aWVzOiBSZWNvcmQ8S2V5LCBFbnRpdHk+O1xufVxuXG4vKipcbiAqIFBhcnNlIGBjaGVja2VkS2V5c2AgdG8geyBjaGVja2VkS2V5cywgaGFsZkNoZWNrZWRLZXlzIH0gc3R5bGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2hlY2tlZEtleXMoa2V5czogS2V5W10gfCB7IGNoZWNrZWQ6IEtleVtdOyBoYWxmQ2hlY2tlZDogS2V5W10gfSkge1xuICBpZiAoIWtleXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENvbnZlcnQga2V5cyB0byBvYmplY3QgZm9ybWF0XG4gIGxldCBrZXlQcm9wcztcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAvLyBbTGVnYWN5XSBGb2xsb3cgdGhlIGFwaSBkb2NcbiAgICBrZXlQcm9wcyA9IHtcbiAgICAgIGNoZWNrZWRLZXlzOiBrZXlzLFxuICAgICAgaGFsZkNoZWNrZWRLZXlzOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Yga2V5cyA9PT0gJ29iamVjdCcpIHtcbiAgICBrZXlQcm9wcyA9IHtcbiAgICAgIGNoZWNrZWRLZXlzOiBrZXlzLmNoZWNrZWQgfHwgdW5kZWZpbmVkLFxuICAgICAgaGFsZkNoZWNrZWRLZXlzOiBrZXlzLmhhbGZDaGVja2VkIHx8IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHdhcm5pbmcoZmFsc2UsICdgY2hlY2tlZEtleXNgIGlzIG5vdCBhbiBhcnJheSBvciBhbiBvYmplY3QnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBrZXlQcm9wcztcbn1cblxuLyoqXG4gKiBJZiB1c2VyIHVzZSBgYXV0b0V4cGFuZFBhcmVudGAgd2Ugc2hvdWxkIGdldCB0aGUgbGlzdCBvZiBwYXJlbnQgbm9kZVxuICogQHBhcmFtIGtleUxpc3RcbiAqIEBwYXJhbSBrZXlFbnRpdGllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29uZHVjdEV4cGFuZFBhcmVudChrZXlMaXN0OiBLZXlbXSwga2V5RW50aXRpZXM6IFJlY29yZDxLZXksIERhdGFFbnRpdHk+KSB7XG4gIGNvbnN0IGV4cGFuZGVkS2V5cyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGNvbmR1Y3RVcChrZXk6IEtleSkge1xuICAgIGlmIChleHBhbmRlZEtleXNba2V5XSkgcmV0dXJuO1xuXG4gICAgY29uc3QgZW50aXR5ID0ga2V5RW50aXRpZXNba2V5XTtcbiAgICBpZiAoIWVudGl0eSkgcmV0dXJuO1xuXG4gICAgZXhwYW5kZWRLZXlzW2tleV0gPSB0cnVlO1xuXG4gICAgY29uc3QgeyBwYXJlbnQsIG5vZGUgfSA9IGVudGl0eTtcblxuICAgIGlmIChub2RlLmRpc2FibGVkKSByZXR1cm47XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBjb25kdWN0VXAocGFyZW50LmtleSk7XG4gICAgfVxuICB9XG5cbiAgKGtleUxpc3QgfHwgW10pLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25kdWN0VXAoa2V5KTtcbiAgfSk7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4cGFuZGVkS2V5cyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBvbmx5IHRoZSBkYXRhLSBhbmQgYXJpYS0ga2V5L3ZhbHVlIHBhaXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhQW5kQXJpYShwcm9wczogUGFydGlhbDxUcmVlUHJvcHMgfCBUcmVlTm9kZVByb3BzPikge1xuICBjb25zdCBvbWl0UHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ2RhdGEtJykgfHwga2V5LnN0YXJ0c1dpdGgoJ2FyaWEtJykpIHtcbiAgICAgIG9taXRQcm9wc1trZXldID0gcHJvcHNba2V5XTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvbWl0UHJvcHM7XG59XG4iXSwidmVyc2lvbiI6M30=