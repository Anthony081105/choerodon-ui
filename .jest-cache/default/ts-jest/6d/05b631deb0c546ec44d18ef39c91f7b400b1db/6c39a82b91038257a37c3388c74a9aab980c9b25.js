import { __decorate } from "tslib";
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { observer } from 'mobx-react';
import classNames from 'classnames';
import { computed, get } from 'mobx';
import { Droppable, Draggable, } from 'react-beautiful-dnd';
import { pxToRem } from 'choerodon-ui/lib/_util/UnitConvertor';
import { isFunction } from 'lodash';
import TableHeaderCell from './TableHeaderCell';
import TableContext from './TableContext';
import { getColumnKey } from './utils';
import autobind from '../_util/autobind';
import { instance } from './Table';
import { DRAG_KEY } from './TableStore';
let TableHeader = class TableHeader extends Component {
    constructor() {
        super(...arguments);
        this.columnDeep = 0;
    }
    saveRef(node) {
        this.node = node;
    }
    getHeaderNode() {
        return this.node;
    }
    render() {
        const { prefixCls, lock, dataSet, dragColumnAlign } = this.props;
        const { groupedColumns } = this;
        const { tableStore: { overflowY, columnMaxDeep, columnResizable, dragColumn, props: { columnsDragRender = {} } }, } = this.context;
        const { droppableProps, draggableProps, renderClone } = columnsDragRender;
        const { tableStore } = this.context;
        const rows = this.getTableHeaderRows(groupedColumns);
        const filterDrag = (columnItem) => {
            if (columnItem && columnItem.column && dragColumnAlign) {
                return columnItem.column.key === DRAG_KEY;
            }
            return true;
        };
        tableStore.columnMaxDeep = (rows.length || 0);
        const trs = rows.map((row, rowIndex) => {
            if (row.length) {
                let prevColumn;
                const tds = row.filter(filterDrag).map(({ hidden, column, rowSpan, colSpan, lastLeaf }, index) => {
                    if (!hidden) {
                        return (React.createElement(Draggable, Object.assign({ draggableId: getColumnKey(column).toString(), index: index, key: getColumnKey(column), isDragDisabled: getColumnKey(column) === DRAG_KEY || (!dragColumn || columnMaxDeep > 1) }, draggableProps), (provided, snapshot) => {
                            const props = {
                                key: getColumnKey(column),
                                prefixCls,
                                dataSet,
                                prevColumn,
                                column,
                                resizeColumn: lastLeaf,
                                getHeaderNode: this.getHeaderNode,
                                provided,
                                snapshot,
                            };
                            if (rowSpan > 1) {
                                props.rowSpan = rowSpan;
                            }
                            if (colSpan > 1) {
                                props.colSpan = colSpan;
                            }
                            prevColumn = lastLeaf;
                            return (React.createElement(TableHeaderCell, Object.assign({}, props)));
                        }));
                    }
                    return undefined;
                });
                if (overflowY && lock !== "left" /* left */ && rowIndex === 0) {
                    tds.push(React.createElement("th", { key: "fixed-column", className: `${prefixCls}-cell`, rowSpan: rows.length }, "\u00A0"));
                }
                return (React.createElement(Droppable, Object.assign({ droppableId: "tableHeader", key: row.length > 1 ? `tableHeader${rowIndex}` : "tableHeader", direction: "horizontal", isDropDisabled: (!dragColumn || columnMaxDeep > 1), renderClone: (provided, snapshot, rubric) => {
                        const rowProps = row[rubric.source.index];
                        const { column, rowSpan, colSpan, lastLeaf } = rowProps;
                        const props = {
                            key: getColumnKey(column),
                            prefixCls,
                            dataSet,
                            prevColumn,
                            column,
                            resizeColumn: lastLeaf,
                            getHeaderNode: this.getHeaderNode,
                            provided,
                            snapshot,
                        };
                        if (rowSpan > 1) {
                            props.rowSpan = rowSpan;
                        }
                        if (colSpan > 1) {
                            props.colSpan = colSpan;
                        }
                        if (renderClone && isFunction(renderClone)) {
                            return renderClone(props);
                        }
                        return (React.createElement(TableHeaderCell, Object.assign({}, props)));
                    }, getContainerForClone: () => instance().headtr }, droppableProps), (droppableProvided) => (React.createElement("tr", Object.assign({ key: String(rowIndex), style: {
                        height: lock ? this.getHeaderRowStyle(rows, rowIndex, columnResizable) : undefined,
                    }, ref: (ref) => {
                        if (ref) {
                            this.saveRef(ref);
                            droppableProvided.innerRef(ref);
                        }
                    } }, droppableProvided.droppableProps),
                    tds,
                    droppableProvided.placeholder))));
            }
            return undefined;
        });
        const classString = classNames(`${prefixCls}-thead`, {
            [`${prefixCls}-column-resizable`]: columnResizable,
        });
        return (React.createElement("thead", { ref: this.saveRef, className: classString }, trs));
    }
    getTableHeaderRows(columns, currentRow = 0, rows = []) {
        rows[currentRow] = rows[currentRow] || [];
        columns.forEach(column => {
            const { hidden, rowSpan, colSpan, children } = column;
            if (!hidden) {
                if (rowSpan && rows.length < rowSpan) {
                    while (rows.length < rowSpan) {
                        rows.push([]);
                    }
                }
                if (children) {
                    this.getTableHeaderRows(children.columns, currentRow + rowSpan, rows);
                }
                if (colSpan !== 0) {
                    rows[currentRow].push(column);
                }
            }
        });
        return rows;
    }
    getHeaderRowStyle(rows, rowIndex, columnResizable) {
        const { tableStore: { rowHeight }, } = this.context;
        const height = rowHeight === 'auto' ? this.getRowHeight(rowIndex++) : rowHeight;
        return pxToRem(rows
            .slice(rowIndex)
            .reduce((total, r, index) => r.length
            ? total
            : total +
                (rowHeight === 'auto'
                    ? this.getRowHeight(index + rowIndex)
                    : rowHeight + (columnResizable ? 4 : 3)), height));
    }
    getRowHeight(index) {
        const { tableStore } = this.context;
        return get(tableStore.lockColumnsHeadRowsHeight, index) || 0;
    }
    get groupedColumns() {
        const { tableStore } = this.context;
        const { lock } = this.props;
        switch (lock) {
            case "left" /* left */:
            case true:
                return tableStore.leftGroupedColumns;
            case "right" /* right */:
                return tableStore.rightGroupedColumns;
            default:
                return tableStore.groupedColumns;
        }
    }
};
TableHeader.displayName = 'TableHeader';
TableHeader.propTypes = {
    prefixCls: PropTypes.string,
    lock: PropTypes.oneOfType([
        PropTypes.bool,
        PropTypes.oneOf(["right" /* right */, "left" /* left */]),
    ]),
    dragColumnAlign: PropTypes.oneOf(["right" /* right */, "left" /* left */]),
};
TableHeader.contextType = TableContext;
__decorate([
    autobind
], TableHeader.prototype, "saveRef", null);
__decorate([
    autobind
], TableHeader.prototype, "getHeaderNode", null);
__decorate([
    computed
], TableHeader.prototype, "groupedColumns", null);
TableHeader = __decorate([
    observer
], TableHeader);
export default TableHeader;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2h1aWh1YXdrL0RvY3VtZW50cy9vcHQvY2hvZXJvZG9uLXVpL2NvbXBvbmVudHMtcHJvL3RhYmxlL1RhYmxlSGVhZGVyLnRzeCIsIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxLQUFLLEVBQUUsRUFBRSxTQUFTLEVBQUUsTUFBTSxPQUFPLENBQUM7QUFDekMsT0FBTyxTQUFTLE1BQU0sWUFBWSxDQUFDO0FBQ25DLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDdEMsT0FBTyxVQUFVLE1BQU0sWUFBWSxDQUFDO0FBQ3BDLE9BQU8sRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3JDLE9BQU8sRUFDTCxTQUFTLEVBQ1QsU0FBUyxHQUtWLE1BQU0scUJBQXFCLENBQUM7QUFDN0IsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQy9ELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFHcEMsT0FBTyxlQUF5QyxNQUFNLG1CQUFtQixDQUFDO0FBQzFFLE9BQU8sWUFBWSxNQUFNLGdCQUFnQixDQUFDO0FBRzFDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFdkMsT0FBTyxRQUFRLE1BQU0sbUJBQW1CLENBQUM7QUFDekMsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUNqQyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBU3hDLElBQXFCLFdBQVcsR0FBaEMsTUFBcUIsV0FBWSxTQUFRLFNBQWdDO0lBQXpFOztRQWdCRSxlQUFVLEdBQVcsQ0FBQyxDQUFBO0lBK054QixDQUFDO0lBNU5DLE9BQU8sQ0FBQyxJQUFJO1FBQ1YsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7SUFDbkIsQ0FBQztJQUdELGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDbkIsQ0FBQztJQUVELE1BQU07UUFDSixNQUFNLEVBQUUs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QUFDLE1BQU07SUFDM0IsSUFBSSxFQUFFLFNBQVMsQ0FBQyxTQUFTLENBQUM7UUFDeEIsU0FBUyxDQUFDLElBQUk7UUFDZCxTQUFTLENBQUMsS0FBSyxDQUFDLHdDQUFtQyxDQUFDO0tBQ3JELENBQUM7SUFDRixlQUFlLEVBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyx3Q0FBNkMsQ0FBQztDQUMvRSxDQUFDO0FBRUssdUJBQVcsR0FBRyxZQUFZLENBQUM7QUFPbEM7SUFEQyxRQUFROzBDQUdSO0FBR0Q7SUFEQyxRQUFRO2dEQUdSO0FBd01EO0lBREMsUUFBUTtpREFhUjtBQTlPa0IsV0FBVztJQUQvQixRQUFRO0dBQ1ksV0FBVyxDQStPL0I7ZUEvT29CLFdBQVciLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2h1aWh1YXdrL0RvY3VtZW50cy9vcHQvY2hvZXJvZG9uLXVpL2NvbXBvbmVudHMtcHJvL3RhYmxlL1RhYmxlSGVhZGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IG9ic2VydmVyIH0gZnJvbSAnbW9ieC1yZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IGNvbXB1dGVkLCBnZXQgfSBmcm9tICdtb2J4JztcbmltcG9ydCB7XG4gIERyb3BwYWJsZSxcbiAgRHJhZ2dhYmxlLFxuICBEcmFnZ2FibGVQcm92aWRlZCxcbiAgRHJhZ2dhYmxlU3RhdGVTbmFwc2hvdCxcbiAgRHJvcHBhYmxlUHJvdmlkZWQsXG4gIERyYWdnYWJsZVJ1YnJpYyxcbn0gZnJvbSAncmVhY3QtYmVhdXRpZnVsLWRuZCc7XG5pbXBvcnQgeyBweFRvUmVtIH0gZnJvbSAnY2hvZXJvZG9uLXVpL2xpYi9fdXRpbC9Vbml0Q29udmVydG9yJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgQ29sdW1uUHJvcHMgfSBmcm9tICcuL0NvbHVtbic7XG5pbXBvcnQgeyBFbGVtZW50UHJvcHMgfSBmcm9tICcuLi9jb3JlL1ZpZXdDb21wb25lbnQnO1xuaW1wb3J0IFRhYmxlSGVhZGVyQ2VsbCwgeyBUYWJsZUhlYWRlckNlbGxQcm9wcyB9IGZyb20gJy4vVGFibGVIZWFkZXJDZWxsJztcbmltcG9ydCBUYWJsZUNvbnRleHQgZnJvbSAnLi9UYWJsZUNvbnRleHQnO1xuaW1wb3J0IHsgQ29sdW1uTG9jayAsRHJhZ0NvbHVtbkFsaWdufSBmcm9tICcuL2VudW0nO1xuaW1wb3J0IERhdGFTZXQgZnJvbSAnLi4vZGF0YS1zZXQvRGF0YVNldCc7XG5pbXBvcnQgeyBnZXRDb2x1bW5LZXkgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBDb2x1bW5Hcm91cCBmcm9tICcuL0NvbHVtbkdyb3VwJztcbmltcG9ydCBhdXRvYmluZCBmcm9tICcuLi9fdXRpbC9hdXRvYmluZCc7XG5pbXBvcnQge2luc3RhbmNlfSBmcm9tICcuL1RhYmxlJztcbmltcG9ydCB7IERSQUdfS0VZIH0gZnJvbSAnLi9UYWJsZVN0b3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUhlYWRlclByb3BzIGV4dGVuZHMgRWxlbWVudFByb3BzIHtcbiAgZGF0YVNldDogRGF0YVNldDtcbiAgbG9jaz86IENvbHVtbkxvY2sgfCBib29sZWFuO1xuICBkcmFnQ29sdW1uQWxpZ24/OkRyYWdDb2x1bW5BbGlnbjtcbn1cblxuQG9ic2VydmVyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJsZUhlYWRlciBleHRlbmRzIENvbXBvbmVudDxUYWJsZUhlYWRlclByb3BzLCBhbnk+IHtcbiAgc3RhdGljIGRpc3BsYXlOYW1lID0gJ1RhYmxlSGVhZGVyJztcblxuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIHByZWZpeENsczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBsb2NrOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5ib29sLFxuICAgICAgUHJvcFR5cGVzLm9uZU9mKFtDb2x1bW5Mb2NrLnJpZ2h0LCBDb2x1bW5Mb2NrLmxlZnRdKSxcbiAgICBdKSxcbiAgICBkcmFnQ29sdW1uQWxpZ246UHJvcFR5cGVzLm9uZU9mKFtEcmFnQ29sdW1uQWxpZ24ucmlnaHQsIERyYWdDb2x1bW5BbGlnbi5sZWZ0XSksXG4gIH07XG5cbiAgc3RhdGljIGNvbnRleHRUeXBlID0gVGFibGVDb250ZXh0O1xuXG4gIG5vZGU6IEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50IHwgbnVsbDtcblxuICBjb2x1bW5EZWVwIDpudW1iZXIgPSAwXG5cbiAgQGF1dG9iaW5kXG4gIHNhdmVSZWYobm9kZSkge1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gIH1cblxuICBAYXV0b2JpbmRcbiAgZ2V0SGVhZGVyTm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgcHJlZml4Q2xzLCBsb2NrLCBkYXRhU2V0LGRyYWdDb2x1bW5BbGlnbiB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGdyb3VwZWRDb2x1bW5zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhYmxlU3RvcmU6IHsgb3ZlcmZsb3dZLGNvbHVtbk1heERlZXAsIGNvbHVtblJlc2l6YWJsZSxkcmFnQ29sdW1uLHByb3BzOntjb2x1bW5zRHJhZ1JlbmRlcj17fX19LFxuICAgIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3Qge2Ryb3BwYWJsZVByb3BzLGRyYWdnYWJsZVByb3BzLHJlbmRlckNsb25lfSA9IGNvbHVtbnNEcmFnUmVuZGVyXG4gICAgY29uc3Qge3RhYmxlU3RvcmV9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHJvd3MgPSB0aGlzLmdldFRhYmxlSGVhZGVyUm93cyhncm91cGVkQ29sdW1ucyk7XG4gICAgY29uc3QgZmlsdGVyRHJhZyA9IChjb2x1bW5JdGVtOkNvbHVtbkdyb3VwKTpib29sZWFuID0+IHtcbiAgICAgIGlmKGNvbHVtbkl0ZW0gJiYgY29sdW1uSXRlbS5jb2x1bW4gJiYgZHJhZ0NvbHVtbkFsaWduKXtcbiAgICAgICAgcmV0dXJuIGNvbHVtbkl0ZW0uY29sdW1uLmtleSA9PT0gRFJBR19LRVlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHRhYmxlU3RvcmUuY29sdW1uTWF4RGVlcCA9IChyb3dzLmxlbmd0aCB8fCAwKVxuICAgIGNvbnN0IHRycyA9IHJvd3MubWFwKChyb3csIHJvd0luZGV4KSA9PiB7XG4gICAgICBpZiAocm93Lmxlbmd0aCkge1xuICAgICAgICBsZXQgcHJldkNvbHVtbjogQ29sdW1uUHJvcHMgfCB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHRkcyA9IHJvdy5maWx0ZXIoZmlsdGVyRHJhZykubWFwKCh7IGhpZGRlbiwgY29sdW1uLCByb3dTcGFuLCBjb2xTcGFuLCBsYXN0TGVhZiB9LGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKCFoaWRkZW4pIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8RHJhZ2dhYmxlXG4gICAgICAgICAgICAgIGRyYWdnYWJsZUlkPXtnZXRDb2x1bW5LZXkoY29sdW1uKS50b1N0cmluZygpfVxuICAgICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICAgIGtleT17Z2V0Q29sdW1uS2V5KGNvbHVtbil9XG4gICAgICAgICAgICAgIGlzRHJhZ0Rpc2FibGVkID0ge2dldENvbHVtbktleShjb2x1bW4pID09PSBEUkFHX0tFWSB8fCAoIWRyYWdDb2x1bW4gfHwgY29sdW1uTWF4RGVlcCA+MSkgfVxuICAgICAgICAgICAgICB7Li4uZHJhZ2dhYmxlUHJvcHN9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHsoXG4gICAgICAgICAgICAgICAgcHJvdmlkZWQ6IERyYWdnYWJsZVByb3ZpZGVkLFxuICAgICAgICAgICAgICAgIHNuYXBzaG90OiBEcmFnZ2FibGVTdGF0ZVNuYXBzaG90LFxuICAgICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wczogVGFibGVIZWFkZXJDZWxsUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICBrZXk6IGdldENvbHVtbktleShjb2x1bW4pLFxuICAgICAgICAgICAgICAgICAgcHJlZml4Q2xzLFxuICAgICAgICAgICAgICAgICAgZGF0YVNldCxcbiAgICAgICAgICAgICAgICAgIHByZXZDb2x1bW4sXG4gICAgICAgICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICAgICAgICByZXNpemVDb2x1bW46IGxhc3RMZWFmLFxuICAgICAgICAgICAgICAgICAgZ2V0SGVhZGVyTm9kZTogdGhpcy5nZXRIZWFkZXJOb2RlLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZWQsXG4gICAgICAgICAgICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyb3dTcGFuID4gMSkge1xuICAgICAgICAgICAgICAgICAgcHJvcHMucm93U3BhbiA9IHJvd1NwYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2xTcGFuID4gMSkge1xuICAgICAgICAgICAgICAgICAgcHJvcHMuY29sU3BhbiA9IGNvbFNwYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZDb2x1bW4gPSBsYXN0TGVhZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgPFRhYmxlSGVhZGVyQ2VsbCB7Li4ucHJvcHN9IC8+XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAgICAgICAgICApXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3ZlcmZsb3dZICYmIGxvY2sgIT09IENvbHVtbkxvY2subGVmdCAmJiByb3dJbmRleCA9PT0gMCkge1xuICAgICAgICAgIHRkcy5wdXNoKFxuICAgICAgICAgICAgPHRoIGtleT1cImZpeGVkLWNvbHVtblwiIGNsYXNzTmFtZT17YCR7cHJlZml4Q2xzfS1jZWxsYH0gcm93U3Bhbj17cm93cy5sZW5ndGh9PlxuICAgICAgICAgICAgICAmbmJzcDtcbiAgICAgICAgICAgIDwvdGg+LFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgPERyb3BwYWJsZVxuICAgICAgICBkcm9wcGFibGVJZD1cInRhYmxlSGVhZGVyXCJcbiAgICAgICAga2V5PXsgcm93Lmxlbmd0aCA+IDEgPyBgdGFibGVIZWFkZXIke3Jvd0luZGV4fWA6XCJ0YWJsZUhlYWRlclwiIH1cbiAgICAgICAgZGlyZWN0aW9uPVwiaG9yaXpvbnRhbFwiXG4gICAgICAgIGlzRHJvcERpc2FibGVkID0geyghZHJhZ0NvbHVtbiB8fCBjb2x1bW5NYXhEZWVwID4xKX1cbiAgICAgICAgcmVuZGVyQ2xvbmU9eyhcbiAgICAgICAgICBwcm92aWRlZDogRHJhZ2dhYmxlUHJvdmlkZWQsXG4gICAgICAgICAgc25hcHNob3Q6IERyYWdnYWJsZVN0YXRlU25hcHNob3QsXG4gICAgICAgICAgcnVicmljOiBEcmFnZ2FibGVSdWJyaWMsXG4gICAgICAgICkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJvd1Byb3BzID0gcm93W3J1YnJpYy5zb3VyY2UuaW5kZXhdXG4gICAgICAgICAgY29uc3QgeyAgY29sdW1uLCByb3dTcGFuLCBjb2xTcGFuLCBsYXN0TGVhZiB9ID0gcm93UHJvcHM7XG4gICAgICAgICAgY29uc3QgcHJvcHM6IFRhYmxlSGVhZGVyQ2VsbFByb3BzID0ge1xuICAgICAgICAgICAga2V5OiBnZXRDb2x1bW5LZXkoY29sdW1uKSxcbiAgICAgICAgICAgIHByZWZpeENscyxcbiAgICAgICAgICAgIGRhdGFTZXQsXG4gICAgICAgICAgICBwcmV2Q29sdW1uLFxuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgcmVzaXplQ29sdW1uOiBsYXN0TGVhZixcbiAgICAgICAgICAgIGdldEhlYWRlck5vZGU6IHRoaXMuZ2V0SGVhZGVyTm9kZSxcbiAgICAgICAgICAgIHByb3ZpZGVkLFxuICAgICAgICAgICAgc25hcHNob3QsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAocm93U3BhbiA+IDEpIHtcbiAgICAgICAgICAgIHByb3BzLnJvd1NwYW4gPSByb3dTcGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29sU3BhbiA+IDEpIHtcbiAgICAgICAgICAgIHByb3BzLmNvbFNwYW4gPSBjb2xTcGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZW5kZXJDbG9uZSAmJiBpc0Z1bmN0aW9uKHJlbmRlckNsb25lKSl7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyQ2xvbmUocHJvcHMpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8VGFibGVIZWFkZXJDZWxsXG4gICAgICAgICAgICAgey4uLnByb3BzfSAvPlxuICAgICAgICAgICk7XG4gICAgICAgIH19XG4gICAgICAgIGdldENvbnRhaW5lckZvckNsb25lPXsoKSA9PiBpbnN0YW5jZSgpLmhlYWR0cn1cbiAgICAgICAgey4uLmRyb3BwYWJsZVByb3BzfVxuICAgICAgPlxuICAgICAgICB7KGRyb3BwYWJsZVByb3ZpZGVkOiBEcm9wcGFibGVQcm92aWRlZCkgPT4gKFxuICAgICAgICAgIDx0clxuICAgICAgICAgICAga2V5PXtTdHJpbmcocm93SW5kZXgpfVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgaGVpZ2h0OiBsb2NrID8gdGhpcy5nZXRIZWFkZXJSb3dTdHlsZShyb3dzLCByb3dJbmRleCwgY29sdW1uUmVzaXphYmxlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICByZWY9eyhyZWY6IEhUTUxUYWJsZVJvd0VsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICAgIGlmKHJlZil7XG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlUmVmKHJlZilcbiAgICAgICAgICAgICAgICBkcm9wcGFibGVQcm92aWRlZC5pbm5lclJlZihyZWYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgey4uLmRyb3BwYWJsZVByb3ZpZGVkLmRyb3BwYWJsZVByb3BzfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0ZHN9XG4gICAgICAgICAgICB7ZHJvcHBhYmxlUHJvdmlkZWQucGxhY2Vob2xkZXJ9XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgICAgKX1cbiAgICAgICAgICA8L0Ryb3BwYWJsZT5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgY29uc3QgY2xhc3NTdHJpbmcgPSBjbGFzc05hbWVzKGAke3ByZWZpeENsc30tdGhlYWRgLCB7XG4gICAgICBbYCR7cHJlZml4Q2xzfS1jb2x1bW4tcmVzaXphYmxlYF06IGNvbHVtblJlc2l6YWJsZSxcbiAgICB9KTtcbiAgICByZXR1cm4gKFxuICAgICAgPHRoZWFkIHJlZj17dGhpcy5zYXZlUmVmfSBjbGFzc05hbWU9e2NsYXNzU3RyaW5nfT5cbiAgICAgICAge3Ryc31cbiAgICAgIDwvdGhlYWQ+XG4gICAgKTtcbiAgfVxuXG4gIGdldFRhYmxlSGVhZGVyUm93cyhcbiAgICBjb2x1bW5zOiBDb2x1bW5Hcm91cFtdLFxuICAgIGN1cnJlbnRSb3c6IG51bWJlciA9IDAsXG4gICAgcm93czogQ29sdW1uR3JvdXBbXVtdID0gW10sXG4gICk6IENvbHVtbkdyb3VwW11bXSB7XG4gICAgcm93c1tjdXJyZW50Um93XSA9IHJvd3NbY3VycmVudFJvd10gfHwgW107XG4gICAgY29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICBjb25zdCB7IGhpZGRlbiwgcm93U3BhbiwgY29sU3BhbiwgY2hpbGRyZW4gfSA9IGNvbHVtbjtcbiAgICAgIGlmICghaGlkZGVuKSB7XG4gICAgICAgIGlmIChyb3dTcGFuICYmIHJvd3MubGVuZ3RoIDwgcm93U3Bhbikge1xuICAgICAgICAgIHdoaWxlIChyb3dzLmxlbmd0aCA8IHJvd1NwYW4pIHtcbiAgICAgICAgICAgIHJvd3MucHVzaChbXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgIHRoaXMuZ2V0VGFibGVIZWFkZXJSb3dzKGNoaWxkcmVuLmNvbHVtbnMsIGN1cnJlbnRSb3cgKyByb3dTcGFuLCByb3dzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sU3BhbiAhPT0gMCkge1xuICAgICAgICAgIHJvd3NbY3VycmVudFJvd10ucHVzaChjb2x1bW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBnZXRIZWFkZXJSb3dTdHlsZShcbiAgICByb3dzOiBDb2x1bW5Hcm91cFtdW10sXG4gICAgcm93SW5kZXg6IG51bWJlcixcbiAgICBjb2x1bW5SZXNpemFibGU6IGJvb2xlYW4sXG4gICk6IHN0cmluZyB8IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qge1xuICAgICAgdGFibGVTdG9yZTogeyByb3dIZWlnaHQgfSxcbiAgICB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IGhlaWdodCA9IHJvd0hlaWdodCA9PT0gJ2F1dG8nID8gdGhpcy5nZXRSb3dIZWlnaHQocm93SW5kZXgrKykgOiByb3dIZWlnaHQ7XG4gICAgcmV0dXJuIHB4VG9SZW0oXG4gICAgICByb3dzXG4gICAgICAgIC5zbGljZShyb3dJbmRleClcbiAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAodG90YWwsIHIsIGluZGV4KSA9PlxuICAgICAgICAgICAgci5sZW5ndGhcbiAgICAgICAgICAgICAgPyB0b3RhbFxuICAgICAgICAgICAgICA6IHRvdGFsICtcbiAgICAgICAgICAgICAgICAocm93SGVpZ2h0ID09PSAnYXV0bydcbiAgICAgICAgICAgICAgICAgID8gdGhpcy5nZXRSb3dIZWlnaHQoaW5kZXggKyByb3dJbmRleClcbiAgICAgICAgICAgICAgICAgIDogcm93SGVpZ2h0ICsgKGNvbHVtblJlc2l6YWJsZSA/IDQgOiAzKSksXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICApLFxuICAgICk7XG4gIH1cblxuICBnZXRSb3dIZWlnaHQoaW5kZXgpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgdGFibGVTdG9yZSB9ID0gdGhpcy5jb250ZXh0O1xuICAgIHJldHVybiBnZXQodGFibGVTdG9yZS5sb2NrQ29sdW1uc0hlYWRSb3dzSGVpZ2h0LCBpbmRleCkgfHwgMDtcbiAgfVxuXG4gIEBjb21wdXRlZFxuICBnZXQgZ3JvdXBlZENvbHVtbnMoKTogQ29sdW1uR3JvdXBbXSB7XG4gICAgY29uc3QgeyB0YWJsZVN0b3JlIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgeyBsb2NrIH0gPSB0aGlzLnByb3BzO1xuICAgIHN3aXRjaCAobG9jaykge1xuICAgICAgY2FzZSBDb2x1bW5Mb2NrLmxlZnQ6XG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHJldHVybiB0YWJsZVN0b3JlLmxlZnRHcm91cGVkQ29sdW1ucztcbiAgICAgIGNhc2UgQ29sdW1uTG9jay5yaWdodDpcbiAgICAgICAgcmV0dXJuIHRhYmxlU3RvcmUucmlnaHRHcm91cGVkQ29sdW1ucztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0YWJsZVN0b3JlLmdyb3VwZWRDb2x1bW5zO1xuICAgIH1cbiAgfVxufVxuIl0sInZlcnNpb24iOjN9