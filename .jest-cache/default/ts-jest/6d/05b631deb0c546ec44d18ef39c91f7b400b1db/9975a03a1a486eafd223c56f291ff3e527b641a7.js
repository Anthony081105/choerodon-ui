/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * Handle virtual list of the TreeNodes.
 */
import * as React from 'react';
import VirtualList from 'rc-virtual-list';
import MotionTreeNode from './MotionTreeNode';
import { findExpandedKeys, getExpandRange } from './utils/diffUtil';
import { getTreeNodeProps, getKey } from './utils/treeUtil';
const HIDDEN_STYLE = {
    width: 0,
    height: 0,
    display: 'flex',
    overflow: 'hidden',
    opacity: 0,
    border: 0,
    padding: 0,
    margin: 0,
};
const noop = () => { };
export const MOTION_KEY = `RC_TREE_MOTION_${Math.random()}`;
const MotionNode = {
    key: MOTION_KEY,
};
export const MotionEntity = {
    key: MOTION_KEY,
    level: 0,
    index: 0,
    pos: '0',
    node: MotionNode,
};
const MotionFlattenData = {
    parent: null,
    children: [],
    pos: MotionEntity.pos,
    data: MotionNode,
    /** Hold empty list here since we do not use it */
    isStart: [],
    isEnd: [],
};
/**
 * We only need get visible content items to play the animation.
 */
export function getMinimumRangeTransitionRange(list, height, itemHeight) {
    if (!height) {
        return list;
    }
    return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
    const { data: { key }, pos, } = item;
    return getKey(key, pos);
}
function getAccessibilityPath(item) {
    let path = String(item.data.key);
    let current = item;
    while (current.parent) {
        current = current.parent;
        path = `${current.data.key} > ${path}`;
    }
    return path;
}
const RefNodeList = (props, ref) => {
    const { prefixCls, data, 
    // eslint-disable-next-line no-unused-vars 
    selectable, 
    // eslint-disable-next-line no-unused-vars  
    expandedKeys, selectedKeys, checkedKeys, loadedKeys, loadingKeys, halfCheckedKeys, keyEntities, disabled, dragging, dragOverNodeKey, dropPosition, motion, height, itemHeight, virtual, focusable, activeItem, focused, tabIndex, onKeyDown, onFocus, onBlur, onActiveChange, ...domProps } = props;
    // =============================== Ref ================================
    const listRef = React.useRef(null);
    React.useImperativeHandle(ref, () => ({
        scrollTo: scroll => {
            listRef.current.scrollTo(scroll);
        },
    }));
    // ============================== Motion ==============================
    const [disableVirtual, setDisableVirtual] = React.useState(false);
    const [prevExpandedKeys, setPrevExpandedKeys] = React.useState(expandedKeys);
    const [prevData, setPrevData] = React.useState(data);
    const [transitionData, setTransitionData] = React.useState(data);
    const [transitionRange, setTransitionRange] = React.useState([]);
    const [motionType, setMotionType] = React.useState(null);
    function onMotionEnd() {
        setPrevData(data);
        setTransitionData(data);
        setTransitionRange([]);
        setMotionType(null);
        setDisableVirtual(false);
    }
    // Do animation if expanded keys changed
    React.useEffect(() => {
        setPrevExpandedKeys(expandedKeys);
        const diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
        if (diffExpanded.key !== null) {
            if (diffExpanded.add) {
                const keyIndex = prevData.findIndex(({ data: { key } }) => key === diffExpanded.key);
                if (motion)
                    setDisableVirtual(true);
                const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), height, itemHeight);
                const newTransitionData = prevData.slice();
                newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
                setTransitionData(newTransitionData);
                // @ts-ignore
                setTransitionRange(rangeNodes);
                setMotionType('show');
            }
            else {
                const keyIndex = data.findIndex(({ data: { key } }) => key === diffExpanded.key);
                if (motion)
                    setDisableVirtual(true);
                const rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), height, itemHeight);
                const newTransitionData = data.slice();
                newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
                setTransitionData(newTransitionData);
                // @ts-ignore
                setTransitionRange(rangeNodes);
                setMotionType('hide');
            }
        }
        else if (prevData !== data) {
            // If whole data changed, we just refresh the list
            setPrevData(data);
            setTransitionData(data);
        }
    }, [expandedKeys, data]);
    // We should clean up motion if is changed by dragging
    React.useEffect(() => {
        if (!dragging) {
            onMotionEnd();
        }
    }, [dragging]);
    const mergedData = motion ? transitionData : data;
    const treeNodeRequiredProps = {
        expandedKeys,
        selectedKeys,
        loadedKeys,
        loadingKeys,
        checkedKeys,
        halfCheckedKeys,
        dragOverNodeKey,
        dropPosition,
        keyEntities,
    };
    return (React.createElement(React.Fragment, null,
        focused && activeItem && (React.createElement("span", { style: HIDDEN_STYLE, "aria-live": "assertive" }, getAccessibilityPath(activeItem))),
        React.createElement("div", { role: "tree" },
            React.createElement("input", { style: HIDDEN_STYLE, disabled: focusable === false || disabled, tabIndex: focusable !== false ? tabIndex : undefined, onKeyDown: onKeyDown, onFocus: onFocus, onBlur: onBlur, value: "", onChange: noop })),
        React.createElement(VirtualList, Object.assign({}, domProps, { disabled: disableVirtual, data: mergedData, itemKey: itemKey, height: height, fullHeight: false, virtual: virtual, itemHeight: itemHeight, onSkipRender: onMotionEnd, prefixCls: `${prefixCls}-list`, ref: listRef }), (treeNode) => {
            const { pos, data: { key, ...restProps }, isStart, isEnd, } = treeNode;
            const mergedKey = getKey(key, pos);
            delete restProps.children;
            const treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
            return (React.createElement(MotionTreeNode, Object.assign({}, restProps, treeNodeProps, { 
                // @ts-ignore
                active: activeItem && key === activeItem.data.key, pos: pos, data: treeNode.data, isStart: isStart, isEnd: isEnd, motion: motion, motionNodes: key === MOTION_KEY ? transitionRange : null, motionType: motionType, onMotionEnd: onMotionEnd, treeNodeRequiredProps: treeNodeRequiredProps, onMouseMove: () => {
                    // @ts-ignore
                    onActiveChange(null);
                } })));
        })));
};
const NodeList = React.forwardRef(RefNodeList);
NodeList.displayName = 'NodeList';
export default NodeList;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2h1aWh1YXdrL0RvY3VtZW50cy9vcHQvY2hvZXJvZG9uLXVpL2NvbXBvbmVudHMvcmMtY29tcG9uZW50cy90cmVlL05vZGVMaXN0LnRzeCIsIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFDdEQ7O0dBRUc7QUFFSCxPQUFPLEtBQUssS0FBSyxNQUFNLE9BQU8sQ0FBQztBQUMvQixPQUFPLFdBQVcsTUFBTSxpQkFBaUIsQ0FBQztBQUUxQyxPQUFPLGNBQWMsTUFBTSxrQkFBa0IsQ0FBQztBQUM5QyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDcEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRTVELE1BQU0sWUFBWSxHQUFHO0lBQ25CLEtBQUssRUFBRSxDQUFDO0lBQ1IsTUFBTSxFQUFFLENBQUM7SUFDVCxPQUFPLEVBQUUsTUFBTTtJQUNmLFFBQVEsRUFBRSxRQUFRO0lBQ2xCLE9BQU8sRUFBRSxDQUFDO0lBQ1YsTUFBTSxFQUFFLENBQUM7SUFDVCxPQUFPLEVBQUUsQ0FBQztJQUNWLE1BQU0sRUFBRSxDQUFDO0NBQ1YsQ0FBQztBQUVGLE1BQU0sSUFBSSxHQUFHLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQztBQUV0QixNQUFNLENBQUMsTUFBTSxVQUFVLEdBQUcsa0JBQWtCLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDO0FBRTVELE1BQU0sVUFBVSxHQUFhO0lBQzNCLEdBQUcsRUFBRSxVQUFVO0NBQ2hCLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxZQUFZLEdBQWU7SUFDdEMsR0FBRyxFQUFFLFVBQVU7SUFDZixLQUFLLEVBQUUsQ0FBQztJQUNSLEtBQUssRUFBRSxDQUFDO0lBQ1IsR0FBRyxFQUFFLEdBQUc7SUFDUixJQUFJLEVBQUUsVUFBVTtDQUNqQixDQUFDO0FBRUYsTUFBTSxpQkFBaUIsR0FBZ0I7SUFDckMsTUFBTSxFQUFFLElBQUk7SUFDWixRQUFRLEVB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LEdBQUcsVUFBVSxDQUFDO0FBRWxDLGVBQWUsUUFBUSxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9odWlodWF3ay9Eb2N1bWVudHMvb3B0L2Nob2Vyb2Rvbi11aS9jb21wb25lbnRzL3JjLWNvbXBvbmVudHMvdHJlZS9Ob2RlTGlzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4vKipcbiAqIEhhbmRsZSB2aXJ0dWFsIGxpc3Qgb2YgdGhlIFRyZWVOb2Rlcy5cbiAqL1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVmlydHVhbExpc3QgZnJvbSAncmMtdmlydHVhbC1saXN0JztcbmltcG9ydCB7IEZsYXR0ZW5Ob2RlLCBLZXksIERhdGFFbnRpdHksIERhdGFOb2RlLCBTY3JvbGxUbyB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCBNb3Rpb25UcmVlTm9kZSBmcm9tICcuL01vdGlvblRyZWVOb2RlJztcbmltcG9ydCB7IGZpbmRFeHBhbmRlZEtleXMsIGdldEV4cGFuZFJhbmdlIH0gZnJvbSAnLi91dGlscy9kaWZmVXRpbCc7XG5pbXBvcnQgeyBnZXRUcmVlTm9kZVByb3BzLCBnZXRLZXkgfSBmcm9tICcuL3V0aWxzL3RyZWVVdGlsJztcblxuY29uc3QgSElEREVOX1NUWUxFID0ge1xuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgb3BhY2l0eTogMCxcbiAgYm9yZGVyOiAwLFxuICBwYWRkaW5nOiAwLFxuICBtYXJnaW46IDAsXG59O1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbmV4cG9ydCBjb25zdCBNT1RJT05fS0VZID0gYFJDX1RSRUVfTU9USU9OXyR7TWF0aC5yYW5kb20oKX1gO1xuXG5jb25zdCBNb3Rpb25Ob2RlOiBEYXRhTm9kZSA9IHtcbiAga2V5OiBNT1RJT05fS0VZLFxufTtcblxuZXhwb3J0IGNvbnN0IE1vdGlvbkVudGl0eTogRGF0YUVudGl0eSA9IHtcbiAga2V5OiBNT1RJT05fS0VZLFxuICBsZXZlbDogMCxcbiAgaW5kZXg6IDAsXG4gIHBvczogJzAnLFxuICBub2RlOiBNb3Rpb25Ob2RlLFxufTtcblxuY29uc3QgTW90aW9uRmxhdHRlbkRhdGE6IEZsYXR0ZW5Ob2RlID0ge1xuICBwYXJlbnQ6IG51bGwsXG4gIGNoaWxkcmVuOiBbXSxcbiAgcG9zOiBNb3Rpb25FbnRpdHkucG9zLFxuICBkYXRhOiBNb3Rpb25Ob2RlLFxuICAvKiogSG9sZCBlbXB0eSBsaXN0IGhlcmUgc2luY2Ugd2UgZG8gbm90IHVzZSBpdCAqL1xuICBpc1N0YXJ0OiBbXSxcbiAgaXNFbmQ6IFtdLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBOb2RlTGlzdFJlZiB7XG4gIHNjcm9sbFRvOiBTY3JvbGxUbztcbn1cblxuaW50ZXJmYWNlIE5vZGVMaXN0UHJvcHMge1xuICBwcmVmaXhDbHM6IHN0cmluZztcbiAgc3R5bGU6IFJlYWN0LkNTU1Byb3BlcnRpZXM7XG4gIGRhdGE6IEZsYXR0ZW5Ob2RlW107XG4gIG1vdGlvbjogYW55O1xuICBmb2N1c2FibGU/OiBib29sZWFuO1xuICBhY3RpdmVJdGVtOiBGbGF0dGVuTm9kZTtcbiAgZm9jdXNlZD86IGJvb2xlYW47XG4gIHRhYkluZGV4OiBudW1iZXI7XG4gIGNoZWNrYWJsZT86IGJvb2xlYW47XG4gIHNlbGVjdGFibGU/OiBib29sZWFuO1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG5cbiAgZXhwYW5kZWRLZXlzOiBLZXlbXTtcbiAgc2VsZWN0ZWRLZXlzOiBLZXlbXTtcbiAgY2hlY2tlZEtleXM6IEtleVtdO1xuICBsb2FkZWRLZXlzOiBLZXlbXTtcbiAgbG9hZGluZ0tleXM6IEtleVtdO1xuICBoYWxmQ2hlY2tlZEtleXM6IEtleVtdO1xuICBrZXlFbnRpdGllczogUmVjb3JkPEtleSwgRGF0YUVudGl0eT47XG5cbiAgZHJhZ2dpbmc6IGJvb2xlYW47XG4gIGRyYWdPdmVyTm9kZUtleTogS2V5O1xuICBkcm9wUG9zaXRpb246IG51bWJlcjtcblxuICAvLyBWaXJ0dWFsIGxpc3RcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGl0ZW1IZWlnaHQ6IG51bWJlcjtcbiAgdmlydHVhbD86IGJvb2xlYW47XG5cbiAgb25LZXlEb3duPzogUmVhY3QuS2V5Ym9hcmRFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+O1xuICBvbkZvY3VzPzogUmVhY3QuRm9jdXNFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+O1xuICBvbkJsdXI/OiBSZWFjdC5Gb2N1c0V2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD47XG4gIG9uQWN0aXZlQ2hhbmdlOiAoa2V5OiBLZXkpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogV2Ugb25seSBuZWVkIGdldCB2aXNpYmxlIGNvbnRlbnQgaXRlbXMgdG8gcGxheSB0aGUgYW5pbWF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluaW11bVJhbmdlVHJhbnNpdGlvblJhbmdlKFxuICBsaXN0OiBGbGF0dGVuTm9kZVtdLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgaXRlbUhlaWdodDogbnVtYmVyLFxuKSB7XG4gIGlmICghaGVpZ2h0KSB7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICByZXR1cm4gbGlzdC5zbGljZSgwLCBNYXRoLmNlaWwoaGVpZ2h0IC8gaXRlbUhlaWdodCkgKyAxKTtcbn1cblxuZnVuY3Rpb24gaXRlbUtleShpdGVtOiBGbGF0dGVuTm9kZSkge1xuICBjb25zdCB7XG4gICAgZGF0YTogeyBrZXkgfSxcbiAgICBwb3MsXG4gIH0gPSBpdGVtO1xuICByZXR1cm4gZ2V0S2V5KGtleSwgcG9zKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWNjZXNzaWJpbGl0eVBhdGgoaXRlbTogRmxhdHRlbk5vZGUpOiBzdHJpbmcge1xuICBsZXQgcGF0aCA9IFN0cmluZyhpdGVtLmRhdGEua2V5KTtcbiAgbGV0IGN1cnJlbnQgPSBpdGVtO1xuXG4gIHdoaWxlIChjdXJyZW50LnBhcmVudCkge1xuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICBwYXRoID0gYCR7Y3VycmVudC5kYXRhLmtleX0gPiAke3BhdGh9YDtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuXG5jb25zdCBSZWZOb2RlTGlzdDogUmVhY3QuUmVmRm9yd2FyZGluZ0NvbXBvbmVudDxOb2RlTGlzdFJlZiwgTm9kZUxpc3RQcm9wcz4gPSAoXG4gIHByb3BzLFxuICByZWYsXG4pID0+IHtcbiAgY29uc3Qge1xuICAgIHByZWZpeENscyxcbiAgICBkYXRhLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyBcbiAgICBzZWxlY3RhYmxlLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAgXG4gICAgZXhwYW5kZWRLZXlzLFxuICAgIHNlbGVjdGVkS2V5cyxcbiAgICBjaGVja2VkS2V5cyxcbiAgICBsb2FkZWRLZXlzLFxuICAgIGxvYWRpbmdLZXlzLFxuICAgIGhhbGZDaGVja2VkS2V5cyxcbiAgICBrZXlFbnRpdGllcyxcbiAgICBkaXNhYmxlZCxcblxuICAgIGRyYWdnaW5nLFxuICAgIGRyYWdPdmVyTm9kZUtleSxcbiAgICBkcm9wUG9zaXRpb24sXG4gICAgbW90aW9uLFxuXG4gICAgaGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQsXG4gICAgdmlydHVhbCxcblxuICAgIGZvY3VzYWJsZSxcbiAgICBhY3RpdmVJdGVtLFxuICAgIGZvY3VzZWQsXG4gICAgdGFiSW5kZXgsXG5cbiAgICBvbktleURvd24sXG4gICAgb25Gb2N1cyxcbiAgICBvbkJsdXIsXG4gICAgb25BY3RpdmVDaGFuZ2UsXG5cbiAgICAuLi5kb21Qcm9wc1xuICB9ID0gcHJvcHM7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSBSZWYgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgbGlzdFJlZiA9IFJlYWN0LnVzZVJlZjxWaXJ0dWFsTGlzdDxGbGF0dGVuTm9kZT4+KG51bGwpO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gKHtcbiAgICBzY3JvbGxUbzogc2Nyb2xsID0+IHtcbiAgICAgIGxpc3RSZWYuY3VycmVudCEuc2Nyb2xsVG8oc2Nyb2xsKTtcbiAgICB9LFxuICB9KSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IE1vdGlvbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgW2Rpc2FibGVWaXJ0dWFsLCBzZXREaXNhYmxlVmlydHVhbF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtwcmV2RXhwYW5kZWRLZXlzLCBzZXRQcmV2RXhwYW5kZWRLZXlzXSA9IFJlYWN0LnVzZVN0YXRlKGV4cGFuZGVkS2V5cyk7XG4gIGNvbnN0IFtwcmV2RGF0YSwgc2V0UHJldkRhdGFdID0gUmVhY3QudXNlU3RhdGUoZGF0YSk7XG4gIGNvbnN0IFt0cmFuc2l0aW9uRGF0YSwgc2V0VHJhbnNpdGlvbkRhdGFdID0gUmVhY3QudXNlU3RhdGUoZGF0YSk7XG4gIGNvbnN0IFt0cmFuc2l0aW9uUmFuZ2UsIHNldFRyYW5zaXRpb25SYW5nZV0gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFttb3Rpb25UeXBlLCBzZXRNb3Rpb25UeXBlXSA9IFJlYWN0LnVzZVN0YXRlPCdzaG93JyB8ICdoaWRlJyB8IG51bGw+KFxuICAgIG51bGwsXG4gICk7XG5cbiAgZnVuY3Rpb24gb25Nb3Rpb25FbmQoKSB7XG4gICAgc2V0UHJldkRhdGEoZGF0YSk7XG4gICAgc2V0VHJhbnNpdGlvbkRhdGEoZGF0YSk7XG4gICAgc2V0VHJhbnNpdGlvblJhbmdlKFtdKTtcbiAgICBzZXRNb3Rpb25UeXBlKG51bGwpO1xuICAgIHNldERpc2FibGVWaXJ0dWFsKGZhbHNlKTtcbiAgfVxuXG4gIC8vIERvIGFuaW1hdGlvbiBpZiBleHBhbmRlZCBrZXlzIGNoYW5nZWRcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRQcmV2RXhwYW5kZWRLZXlzKGV4cGFuZGVkS2V5cyk7XG5cbiAgICBjb25zdCBkaWZmRXhwYW5kZWQgPSBmaW5kRXhwYW5kZWRLZXlzKHByZXZFeHBhbmRlZEtleXMsIGV4cGFuZGVkS2V5cyk7XG5cbiAgICBpZiAoZGlmZkV4cGFuZGVkLmtleSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZmZFeHBhbmRlZC5hZGQpIHtcbiAgICAgICAgY29uc3Qga2V5SW5kZXggPSBwcmV2RGF0YS5maW5kSW5kZXgoXG4gICAgICAgICAgKHsgZGF0YTogeyBrZXkgfSB9KSA9PiBrZXkgPT09IGRpZmZFeHBhbmRlZC5rZXksXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG1vdGlvbikgc2V0RGlzYWJsZVZpcnR1YWwodHJ1ZSk7XG4gICAgICAgIGNvbnN0IHJhbmdlTm9kZXMgPSBnZXRNaW5pbXVtUmFuZ2VUcmFuc2l0aW9uUmFuZ2UoXG4gICAgICAgICAgZ2V0RXhwYW5kUmFuZ2UocHJldkRhdGEsIGRhdGEsIGRpZmZFeHBhbmRlZC5rZXkpLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBpdGVtSGVpZ2h0LFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IG5ld1RyYW5zaXRpb25EYXRhOiBGbGF0dGVuTm9kZVtdID0gcHJldkRhdGEuc2xpY2UoKTtcbiAgICAgICAgbmV3VHJhbnNpdGlvbkRhdGEuc3BsaWNlKGtleUluZGV4ICsgMSwgMCwgTW90aW9uRmxhdHRlbkRhdGEpO1xuXG4gICAgICAgIHNldFRyYW5zaXRpb25EYXRhKG5ld1RyYW5zaXRpb25EYXRhKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBzZXRUcmFuc2l0aW9uUmFuZ2UocmFuZ2VOb2Rlcyk7XG4gICAgICAgIHNldE1vdGlvblR5cGUoJ3Nob3cnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGtleUluZGV4ID0gZGF0YS5maW5kSW5kZXgoXG4gICAgICAgICAgKHsgZGF0YTogeyBrZXkgfSB9KSA9PiBrZXkgPT09IGRpZmZFeHBhbmRlZC5rZXksXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG1vdGlvbikgc2V0RGlzYWJsZVZpcnR1YWwodHJ1ZSk7XG4gICAgICAgIGNvbnN0IHJhbmdlTm9kZXMgPSBnZXRNaW5pbXVtUmFuZ2VUcmFuc2l0aW9uUmFuZ2UoXG4gICAgICAgICAgZ2V0RXhwYW5kUmFuZ2UoZGF0YSwgcHJldkRhdGEsIGRpZmZFeHBhbmRlZC5rZXkpLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBpdGVtSGVpZ2h0LFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IG5ld1RyYW5zaXRpb25EYXRhOiBGbGF0dGVuTm9kZVtdID0gZGF0YS5zbGljZSgpO1xuICAgICAgICBuZXdUcmFuc2l0aW9uRGF0YS5zcGxpY2Uoa2V5SW5kZXggKyAxLCAwLCBNb3Rpb25GbGF0dGVuRGF0YSk7XG5cbiAgICAgICAgc2V0VHJhbnNpdGlvbkRhdGEobmV3VHJhbnNpdGlvbkRhdGEpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHNldFRyYW5zaXRpb25SYW5nZShyYW5nZU5vZGVzKTtcbiAgICAgICAgc2V0TW90aW9uVHlwZSgnaGlkZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldkRhdGEgIT09IGRhdGEpIHtcbiAgICAgIC8vIElmIHdob2xlIGRhdGEgY2hhbmdlZCwgd2UganVzdCByZWZyZXNoIHRoZSBsaXN0XG4gICAgICBzZXRQcmV2RGF0YShkYXRhKTtcbiAgICAgIHNldFRyYW5zaXRpb25EYXRhKGRhdGEpO1xuICAgIH1cbiAgfSwgW2V4cGFuZGVkS2V5cywgZGF0YV0pO1xuXG4gIC8vIFdlIHNob3VsZCBjbGVhbiB1cCBtb3Rpb24gaWYgaXMgY2hhbmdlZCBieSBkcmFnZ2luZ1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgIG9uTW90aW9uRW5kKCk7XG4gICAgfVxuICB9LCBbZHJhZ2dpbmddKTtcblxuICBjb25zdCBtZXJnZWREYXRhID0gbW90aW9uID8gdHJhbnNpdGlvbkRhdGEgOiBkYXRhO1xuXG4gIGNvbnN0IHRyZWVOb2RlUmVxdWlyZWRQcm9wcyA9IHtcbiAgICBleHBhbmRlZEtleXMsXG4gICAgc2VsZWN0ZWRLZXlzLFxuICAgIGxvYWRlZEtleXMsXG4gICAgbG9hZGluZ0tleXMsXG4gICAgY2hlY2tlZEtleXMsXG4gICAgaGFsZkNoZWNrZWRLZXlzLFxuICAgIGRyYWdPdmVyTm9kZUtleSxcbiAgICBkcm9wUG9zaXRpb24sXG4gICAga2V5RW50aXRpZXMsXG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAge2ZvY3VzZWQgJiYgYWN0aXZlSXRlbSAmJiAoXG4gICAgICAgIDxzcGFuIHN0eWxlPXtISURERU5fU1RZTEV9IGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiPlxuICAgICAgICAgIHtnZXRBY2Nlc3NpYmlsaXR5UGF0aChhY3RpdmVJdGVtKX1cbiAgICAgICAgPC9zcGFuPlxuICAgICAgKX1cblxuICAgICAgPGRpdiByb2xlPVwidHJlZVwiPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICBzdHlsZT17SElEREVOX1NUWUxFfVxuICAgICAgICAgIGRpc2FibGVkPXtmb2N1c2FibGUgPT09IGZhbHNlIHx8IGRpc2FibGVkfVxuICAgICAgICAgIHRhYkluZGV4PXtmb2N1c2FibGUgIT09IGZhbHNlID8gdGFiSW5kZXggOiB1bmRlZmluZWR9XG4gICAgICAgICAgb25LZXlEb3duPXtvbktleURvd259XG4gICAgICAgICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICAgICAgICBvbkJsdXI9e29uQmx1cn1cbiAgICAgICAgICB2YWx1ZT1cIlwiXG4gICAgICAgICAgb25DaGFuZ2U9e25vb3B9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPFZpcnR1YWxMaXN0PEZsYXR0ZW5Ob2RlPlxuICAgICAgICB7Li4uZG9tUHJvcHN9XG4gICAgICAgIGRpc2FibGVkPXtkaXNhYmxlVmlydHVhbH1cbiAgICAgICAgZGF0YT17bWVyZ2VkRGF0YX1cbiAgICAgICAgaXRlbUtleT17aXRlbUtleX1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIGZ1bGxIZWlnaHQ9e2ZhbHNlfVxuICAgICAgICB2aXJ0dWFsPXt2aXJ0dWFsfVxuICAgICAgICBpdGVtSGVpZ2h0PXtpdGVtSGVpZ2h0fVxuICAgICAgICBvblNraXBSZW5kZXI9e29uTW90aW9uRW5kfVxuICAgICAgICBwcmVmaXhDbHM9e2Ake3ByZWZpeENsc30tbGlzdGB9XG4gICAgICAgIHJlZj17bGlzdFJlZn1cbiAgICAgID5cbiAgICAgICAgeyh0cmVlTm9kZTogRmxhdHRlbk5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICBkYXRhOiB7IGtleSwgLi4ucmVzdFByb3BzIH0sXG4gICAgICAgICAgICBpc1N0YXJ0LFxuICAgICAgICAgICAgaXNFbmQsXG4gICAgICAgICAgfSA9IHRyZWVOb2RlO1xuICAgICAgICAgIGNvbnN0IG1lcmdlZEtleSA9IGdldEtleShrZXksIHBvcyk7XG4gICAgICAgICAgZGVsZXRlIHJlc3RQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICAgIGNvbnN0IHRyZWVOb2RlUHJvcHMgPSBnZXRUcmVlTm9kZVByb3BzKFxuICAgICAgICAgICAgbWVyZ2VkS2V5LFxuICAgICAgICAgICAgdHJlZU5vZGVSZXF1aXJlZFByb3BzLFxuICAgICAgICAgICk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxNb3Rpb25UcmVlTm9kZVxuICAgICAgICAgICAgICB7Li4ucmVzdFByb3BzfVxuICAgICAgICAgICAgICB7Li4udHJlZU5vZGVQcm9wc31cbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICBhY3RpdmU9e2FjdGl2ZUl0ZW0gJiYga2V5ID09PSBhY3RpdmVJdGVtLmRhdGEua2V5fVxuICAgICAgICAgICAgICBwb3M9e3Bvc31cbiAgICAgICAgICAgICAgZGF0YT17dHJlZU5vZGUuZGF0YX1cbiAgICAgICAgICAgICAgaXNTdGFydD17aXNTdGFydH1cbiAgICAgICAgICAgICAgaXNFbmQ9e2lzRW5kfVxuICAgICAgICAgICAgICBtb3Rpb249e21vdGlvbn1cbiAgICAgICAgICAgICAgbW90aW9uTm9kZXM9e2tleSA9PT0gTU9USU9OX0tFWSA/IHRyYW5zaXRpb25SYW5nZSA6IG51bGx9XG4gICAgICAgICAgICAgIG1vdGlvblR5cGU9e21vdGlvblR5cGV9XG4gICAgICAgICAgICAgIG9uTW90aW9uRW5kPXtvbk1vdGlvbkVuZH1cbiAgICAgICAgICAgICAgdHJlZU5vZGVSZXF1aXJlZFByb3BzPXt0cmVlTm9kZVJlcXVpcmVkUHJvcHN9XG4gICAgICAgICAgICAgIG9uTW91c2VNb3ZlPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIG9uQWN0aXZlQ2hhbmdlKG51bGwpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuICAgICAgICB9fVxuICAgICAgPC9WaXJ0dWFsTGlzdD5cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmNvbnN0IE5vZGVMaXN0ID0gUmVhY3QuZm9yd2FyZFJlZihSZWZOb2RlTGlzdCk7XG5Ob2RlTGlzdC5kaXNwbGF5TmFtZSA9ICdOb2RlTGlzdCc7XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVMaXN0O1xuIl0sInZlcnNpb24iOjN9