import toArray from 'rc-util/lib/Children/toArray';
import warning from 'rc-util/lib/warning';
// @ts-ignore
import { getPosition, isTreeNode } from '../util';
export function getKey(key, pos) {
    if (key !== null && key !== undefined) {
        return key;
    }
    return pos;
}
/**
 * Warning if TreeNode do not provides key
 */
export function warningWithoutKey(treeData = []) {
    const keys = new Map();
    function dig(list, path = '') {
        (list || []).forEach(treeNode => {
            const { key, children } = treeNode;
            warning(key !== null && key !== undefined, `Tree node must have a certain key: [${path}${key}]`);
            const recordKey = String(key);
            warning(!keys.has(recordKey) || key === null || key === undefined, `Same 'key' exist in the Tree: ${recordKey}`);
            keys.set(recordKey, true);
            dig(children, `${path}${recordKey} > `);
        });
    }
    dig(treeData);
}
/**
 * Convert `children` of Tree into `treeData` structure.
 */
export function convertTreeToData(rootNodes) {
    function dig(node) {
        const treeNodes = toArray(node);
        return treeNodes
            .map(treeNode => {
            // Filter invalidate node
            if (!isTreeNode(treeNode)) {
                warning(!treeNode, 'Tree/TreeNode can only accept TreeNode as children.');
                return null;
            }
            const { key } = treeNode;
            const { children, ...rest } = treeNode.props;
            const dataNode = {
                key,
                ...rest,
            };
            const parsedChildren = dig(children);
            if (parsedChildren.length) {
                dataNode.children = parsedChildren;
            }
            return dataNode;
        })
            .filter((dataNode) => dataNode);
    }
    return dig(rootNodes);
}
/**
 * Flat nest tree data into flatten list. This is used for virtual list render.
 * @param treeNodeList Origin data node list
 * @param expandedKeys
 * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).
 */
export function flattenTreeData(treeNodeList = [], expandedKeys = []) {
    const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
    const flattenList = [];
    function dig(list, parent = null) {
        return list.map((treeNode, index) => {
            const pos = getPosition(parent ? parent.pos : '0', index);
            const mergedKey = getKey(treeNode.key, pos);
            // Add FlattenDataNode into list
            const flattenNode = {
                ...treeNode,
                parent,
                pos,
                children: null,
                data: treeNode,
                isStart: [...(parent ? parent.isStart : []), index === 0],
                isEnd: [...(parent ? parent.isEnd : []), index === list.length - 1],
            };
            flattenList.push(flattenNode);
            // Loop treeNode children
            if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
                flattenNode.children = dig(treeNode.children || [], flattenNode);
            }
            else {
                flattenNode.children = [];
            }
            return flattenNode;
        });
    }
    dig(treeNodeList);
    return flattenList;
}
/**
 * Traverse all the data by `treeData`.
 * Please not use it out of the `rc-tree` since we may refactor this code.
 */
export function traverseDataNodes(dataNodes, callback) {
    function processNode(node, index, parent) {
        const children = node ? node.children : dataNodes;
        const pos = node ? getPosition(parent.pos, index) : '0';
        // Process node if is not root
        if (node) {
            const data = {
                node,
                index,
                pos,
                key: node.key !== null ? node.key : pos,
                parentPos: parent.node ? parent.pos : null,
                level: parent.level + 1,
            };
            callback(data);
        }
        // Process children node
        if (children) {
            children.forEach((subNode, subIndex) => {
                processNode(subNode, subIndex, {
                    node,
                    pos,
                    level: parent ? parent.level + 1 : -1,
                });
            });
        }
    }
    processNode(null);
}
/**
 * Convert `treeData` into entity records.
 */
export function convertDataToEntities(dataNodes, { initWrapper, processEntity, onProcessFinished, } = {}) {
    const posEntities = {};
    const keyEntities = {};
    let wrapper = {
        posEntities,
        keyEntities,
    };
    if (initWrapper) {
        wrapper = initWrapper(wrapper) || wrapper;
    }
    traverseDataNodes(dataNodes, item => {
        const { node, index, pos, key, parentPos, level } = item;
        const entity = { node, index, key, pos, level };
        const mergedKey = getKey(key, pos);
        posEntities[pos] = entity;
        keyEntities[mergedKey] = entity;
        // Fill children
        entity.parent = posEntities[parentPos];
        if (entity.parent) {
            entity.parent.children = entity.parent.children || [];
            entity.parent.children.push(entity);
        }
        if (processEntity) {
            processEntity(entity, wrapper);
        }
    });
    if (onProcessFinished) {
        onProcessFinished(wrapper);
    }
    return wrapper;
}
/**
 * Get TreeNode props with Tree props.
 */
export function getTreeNodeProps(key, { expandedKeys, selectedKeys, loadedKeys, loadingKeys, checkedKeys, halfCheckedKeys, dragOverNodeKey, dropPosition, keyEntities, }) {
    const entity = keyEntities[key];
    const treeNodeProps = {
        eventKey: key,
        expanded: expandedKeys.indexOf(key) !== -1,
        selected: selectedKeys.indexOf(key) !== -1,
        loaded: loadedKeys.indexOf(key) !== -1,
        loading: loadingKeys.indexOf(key) !== -1,
        checked: checkedKeys.indexOf(key) !== -1,
        halfChecked: halfCheckedKeys.indexOf(key) !== -1,
        pos: String(entity ? entity.pos : ''),
        // [Legacy] Drag props
        dragOver: dragOverNodeKey === key && dropPosition === 0,
        dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
        dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1,
    };
    return treeNodeProps;
}
export function convertNodePropsToEventData(props) {
    const { data, expanded, selected, checked, loaded, loading, halfChecked, dragOver, dragOverGapTop, dragOverGapBottom, pos, active, } = props;
    const eventData = {
        ...data,
        expanded,
        selected,
        checked,
        loaded,
        loading,
        halfChecked,
        dragOver,
        dragOverGapTop,
        dragOverGapBottom,
        pos,
        active,
    };
    if (!('props' in eventData)) {
        Object.defineProperty(eventData, 'props', {
            get() {
                warning(false, 'Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.');
                return props;
            },
        });
    }
    return eventData;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2h1aWh1YXdrL0RvY3VtZW50cy9vcHQvY2hvZXJvZG9uLXVpL2NvbXBvbmVudHMvcmMtY29tcG9uZW50cy90cmVlL3V0aWxzL3RyZWVVdGlsLnRzIiwibWFwcGluZ3MiOiJBQUVBLE9BQU8sT0FBTyxNQUFNLDhCQUE4QixDQUFDO0FBQ25ELE9BQU8sT0FBTyxNQUFNLHFCQUFxQixDQUFDO0FBUzFDLGFBQWE7QUFDYixPQUFPLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUdsRCxNQUFNLFVBQVUsTUFBTSxDQUFDLEdBQVEsRUFBRSxHQUFXO0lBQzFDLElBQUksR0FBRyxLQUFLLElBQUksSUFBSSxHQUFHLEtBQUssU0FBUyxFQUFFO1FBQ3JDLE9BQU8sR0FBRyxDQUFDO0tBQ1o7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxXQUF1QixFQUFFO0lBQ3pELE1BQU0sSUFBSSxHQUF5QixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBRTdDLFNBQVMsR0FBRyxDQUFDLElBQWdCLEVBQUUsT0FBZSxFQUFFO1FBQzlDLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUM5QixNQUFNLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxHQUFHLFFBQVEsQ0FBQztZQUNuQyxPQUFPLENBQ0wsR0FBRyxLQUFLLElBQUksSUFBSSxHQUFHLEtBQUssU0FBUyxFQUNqQyx1Q0FBdUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUNyRCxDQUFDO1lBRUYsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzlCLE9BQU8sQ0FDTCxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxLQUFLLElBQUksSUFBSSxHQUFHLEtBQUssU0FBUyxFQUN6RCxpQ0FBaUMsU0FBUyxFQUFFLENBQzdDLENBQUM7WUFD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QUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxTQUFTLENBQUMsRUFBRTtRQUMzQixNQUFNLENBQUMsY0FBYyxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUU7WUFDeEMsR0FBRztnQkFDRCxPQUFPLENBQ0wsS0FBSyxFQUNMLHVJQUF1SSxDQUN4SSxDQUFDO2dCQUNGLE9BQU8sS0FBSyxDQUFDO1lBQ2YsQ0FBQztTQUNGLENBQUMsQ0FBQztLQUNKO0lBRUQsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvaHVpaHVhd2svRG9jdW1lbnRzL29wdC9jaG9lcm9kb24tdWkvY29tcG9uZW50cy9yYy1jb21wb25lbnRzL3RyZWUvdXRpbHMvdHJlZVV0aWwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB0b0FycmF5IGZyb20gJ3JjLXV0aWwvbGliL0NoaWxkcmVuL3RvQXJyYXknO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAncmMtdXRpbC9saWIvd2FybmluZyc7XG5pbXBvcnQge1xuICBEYXRhTm9kZSxcbiAgRmxhdHRlbk5vZGUsXG4gIE5vZGVFbGVtZW50LFxuICBEYXRhRW50aXR5LFxuICBLZXksXG4gIEV2ZW50RGF0YU5vZGUsXG59IGZyb20gJy4uL2ludGVyZmFjZSc7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBnZXRQb3NpdGlvbiwgaXNUcmVlTm9kZSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgVHJlZU5vZGVQcm9wcyB9IGZyb20gJy4uL1RyZWVOb2RlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEtleShrZXk6IEtleSwgcG9zOiBzdHJpbmcpIHtcbiAgaWYgKGtleSAhPT0gbnVsbCAmJiBrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgcmV0dXJuIHBvcztcbn1cblxuLyoqXG4gKiBXYXJuaW5nIGlmIFRyZWVOb2RlIGRvIG5vdCBwcm92aWRlcyBrZXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdhcm5pbmdXaXRob3V0S2V5KHRyZWVEYXRhOiBEYXRhTm9kZVtdID0gW10pIHtcbiAgY29uc3Qga2V5czogTWFwPHN0cmluZywgYm9vbGVhbj4gPSBuZXcgTWFwKCk7XG5cbiAgZnVuY3Rpb24gZGlnKGxpc3Q6IERhdGFOb2RlW10sIHBhdGg6IHN0cmluZyA9ICcnKSB7XG4gICAgKGxpc3QgfHwgW10pLmZvckVhY2godHJlZU5vZGUgPT4ge1xuICAgICAgY29uc3QgeyBrZXksIGNoaWxkcmVuIH0gPSB0cmVlTm9kZTtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGtleSAhPT0gbnVsbCAmJiBrZXkgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgYFRyZWUgbm9kZSBtdXN0IGhhdmUgYSBjZXJ0YWluIGtleTogWyR7cGF0aH0ke2tleX1dYCxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlY29yZEtleSA9IFN0cmluZyhrZXkpO1xuICAgICAgd2FybmluZyhcbiAgICAgICAgIWtleXMuaGFzKHJlY29yZEtleSkgfHwga2V5ID09PSBudWxsIHx8IGtleSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICBgU2FtZSAna2V5JyBleGlzdCBpbiB0aGUgVHJlZTogJHtyZWNvcmRLZXl9YCxcbiAgICAgICk7XG4gICAgICBrZXlzLnNldChyZWNvcmRLZXksIHRydWUpO1xuXG4gICAgICBkaWcoY2hpbGRyZW4sIGAke3BhdGh9JHtyZWNvcmRLZXl9ID4gYCk7XG4gICAgfSk7XG4gIH1cblxuICBkaWcodHJlZURhdGEpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYGNoaWxkcmVuYCBvZiBUcmVlIGludG8gYHRyZWVEYXRhYCBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VHJlZVRvRGF0YShyb290Tm9kZXM6IFJlYWN0LlJlYWN0Tm9kZSk6IERhdGFOb2RlW10ge1xuICBmdW5jdGlvbiBkaWcobm9kZTogUmVhY3QuUmVhY3ROb2RlKTogRGF0YU5vZGVbXSB7XG4gICAgY29uc3QgdHJlZU5vZGVzID0gdG9BcnJheShub2RlKSBhcyBOb2RlRWxlbWVudFtdO1xuICAgIHJldHVybiB0cmVlTm9kZXNcbiAgICAgIC5tYXAodHJlZU5vZGUgPT4ge1xuICAgICAgICAvLyBGaWx0ZXIgaW52YWxpZGF0ZSBub2RlXG4gICAgICAgIGlmICghaXNUcmVlTm9kZSh0cmVlTm9kZSkpIHtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgIXRyZWVOb2RlLFxuICAgICAgICAgICAgJ1RyZWUvVHJlZU5vZGUgY2FuIG9ubHkgYWNjZXB0IFRyZWVOb2RlIGFzIGNoaWxkcmVuLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsga2V5IH0gPSB0cmVlTm9kZTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gdHJlZU5vZGUucHJvcHM7XG5cbiAgICAgICAgY29uc3QgZGF0YU5vZGU6IERhdGFOb2RlID0ge1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHBhcnNlZENoaWxkcmVuID0gZGlnKGNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHBhcnNlZENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIGRhdGFOb2RlLmNoaWxkcmVuID0gcGFyc2VkQ2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YU5vZGU7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigoZGF0YU5vZGU6IERhdGFOb2RlKSA9PiBkYXRhTm9kZSk7XG4gIH1cblxuICByZXR1cm4gZGlnKHJvb3ROb2Rlcyk7XG59XG5cbi8qKlxuICogRmxhdCBuZXN0IHRyZWUgZGF0YSBpbnRvIGZsYXR0ZW4gbGlzdC4gVGhpcyBpcyB1c2VkIGZvciB2aXJ0dWFsIGxpc3QgcmVuZGVyLlxuICogQHBhcmFtIHRyZWVOb2RlTGlzdCBPcmlnaW4gZGF0YSBub2RlIGxpc3RcbiAqIEBwYXJhbSBleHBhbmRlZEtleXNcbiAqIG5lZWQgZXhwYW5kZWQga2V5cywgcHJvdmlkZXMgYHRydWVgIG1lYW5zIGFsbCBleHBhbmRlZCAodXNlZCBpbiBgcmMtdHJlZS1zZWxlY3RgKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5UcmVlRGF0YShcbiAgdHJlZU5vZGVMaXN0OiBEYXRhTm9kZVtdID0gW10sXG4gIGV4cGFuZGVkS2V5czogS2V5W10gfCB0cnVlID0gW10sXG4pOiBGbGF0dGVuTm9kZVtdIHtcbiAgY29uc3QgZXhwYW5kZWRLZXlTZXQgPSBuZXcgU2V0KGV4cGFuZGVkS2V5cyA9PT0gdHJ1ZSA/IFtdIDogZXhwYW5kZWRLZXlzKTtcbiAgY29uc3QgZmxhdHRlbkxpc3Q6IEZsYXR0ZW5Ob2RlW10gPSBbXTtcblxuICBmdW5jdGlvbiBkaWcobGlzdDogRGF0YU5vZGVbXSwgcGFyZW50OiBGbGF0dGVuTm9kZSA9IG51bGwpOiBGbGF0dGVuTm9kZVtdIHtcbiAgICByZXR1cm4gbGlzdC5tYXAoKHRyZWVOb2RlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcG9zOiBzdHJpbmcgPSBnZXRQb3NpdGlvbihwYXJlbnQgPyBwYXJlbnQucG9zIDogJzAnLCBpbmRleCk7XG4gICAgICBjb25zdCBtZXJnZWRLZXkgPSBnZXRLZXkodHJlZU5vZGUua2V5LCBwb3MpO1xuXG4gICAgICAvLyBBZGQgRmxhdHRlbkRhdGFOb2RlIGludG8gbGlzdFxuICAgICAgY29uc3QgZmxhdHRlbk5vZGU6IEZsYXR0ZW5Ob2RlID0ge1xuICAgICAgICAuLi50cmVlTm9kZSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBwb3MsXG4gICAgICAgIGNoaWxkcmVuOiBudWxsLFxuICAgICAgICBkYXRhOiB0cmVlTm9kZSxcbiAgICAgICAgaXNTdGFydDogWy4uLihwYXJlbnQgPyBwYXJlbnQuaXNTdGFydCA6IFtdKSwgaW5kZXggPT09IDBdLFxuICAgICAgICBpc0VuZDogWy4uLihwYXJlbnQgPyBwYXJlbnQuaXNFbmQgOiBbXSksIGluZGV4ID09PSBsaXN0Lmxlbmd0aCAtIDFdLFxuICAgICAgfTtcblxuICAgICAgZmxhdHRlbkxpc3QucHVzaChmbGF0dGVuTm9kZSk7XG5cbiAgICAgIC8vIExvb3AgdHJlZU5vZGUgY2hpbGRyZW5cbiAgICAgIGlmIChleHBhbmRlZEtleXMgPT09IHRydWUgfHwgZXhwYW5kZWRLZXlTZXQuaGFzKG1lcmdlZEtleSkpIHtcbiAgICAgICAgZmxhdHRlbk5vZGUuY2hpbGRyZW4gPSBkaWcodHJlZU5vZGUuY2hpbGRyZW4gfHwgW10sIGZsYXR0ZW5Ob2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYXR0ZW5Ob2RlLmNoaWxkcmVuID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbGF0dGVuTm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpZyh0cmVlTm9kZUxpc3QpO1xuXG4gIHJldHVybiBmbGF0dGVuTGlzdDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZSBhbGwgdGhlIGRhdGEgYnkgYHRyZWVEYXRhYC5cbiAqIFBsZWFzZSBub3QgdXNlIGl0IG91dCBvZiB0aGUgYHJjLXRyZWVgIHNpbmNlIHdlIG1heSByZWZhY3RvciB0aGlzIGNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmF2ZXJzZURhdGFOb2RlcyhcbiAgZGF0YU5vZGVzOiBEYXRhTm9kZVtdLFxuICBjYWxsYmFjazogKGRhdGE6IHtcbiAgICBub2RlOiBEYXRhTm9kZTtcbiAgICBpbmRleDogbnVtYmVyO1xuICAgIHBvczogc3RyaW5nO1xuICAgIGtleTogS2V5O1xuICAgIHBhcmVudFBvczogc3RyaW5nIHwgbnVtYmVyO1xuICAgIGxldmVsOiBudW1iZXI7XG4gIH0pID0+IHZvaWQsXG4pIHtcbiAgZnVuY3Rpb24gcHJvY2Vzc05vZGUoXG4gICAgbm9kZTogRGF0YU5vZGUsXG4gICAgaW5kZXg/OiBudW1iZXIsXG4gICAgcGFyZW50PzogeyBub2RlOiBEYXRhTm9kZTsgcG9zOiBzdHJpbmc7IGxldmVsOiBudW1iZXIgfSxcbiAgKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlID8gbm9kZS5jaGlsZHJlbiA6IGRhdGFOb2RlcztcbiAgICBjb25zdCBwb3MgPSBub2RlID8gZ2V0UG9zaXRpb24ocGFyZW50LnBvcywgaW5kZXgpIDogJzAnO1xuXG4gICAgLy8gUHJvY2VzcyBub2RlIGlmIGlzIG5vdCByb290XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBwb3MsXG4gICAgICAgIGtleTogbm9kZS5rZXkgIT09IG51bGwgPyBub2RlLmtleSA6IHBvcyxcbiAgICAgICAgcGFyZW50UG9zOiBwYXJlbnQubm9kZSA/IHBhcmVudC5wb3MgOiBudWxsLFxuICAgICAgICBsZXZlbDogcGFyZW50LmxldmVsICsgMSxcbiAgICAgIH07XG5cbiAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgY2hpbGRyZW4gbm9kZVxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoc3ViTm9kZSwgc3ViSW5kZXgpID0+IHtcbiAgICAgICAgcHJvY2Vzc05vZGUoc3ViTm9kZSwgc3ViSW5kZXgsIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHBvcyxcbiAgICAgICAgICBsZXZlbDogcGFyZW50ID8gcGFyZW50LmxldmVsICsgMSA6IC0xLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByb2Nlc3NOb2RlKG51bGwpO1xufVxuXG5pbnRlcmZhY2UgV3JhcHBlciB7XG4gIHBvc0VudGl0aWVzOiBSZWNvcmQ8c3RyaW5nLCBEYXRhRW50aXR5PjtcbiAga2V5RW50aXRpZXM6IFJlY29yZDxLZXksIERhdGFFbnRpdHk+O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYHRyZWVEYXRhYCBpbnRvIGVudGl0eSByZWNvcmRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydERhdGFUb0VudGl0aWVzKFxuICBkYXRhTm9kZXM6IERhdGFOb2RlW10sXG4gIHtcbiAgICBpbml0V3JhcHBlcixcbiAgICBwcm9jZXNzRW50aXR5LFxuICAgIG9uUHJvY2Vzc0ZpbmlzaGVkLFxuICB9OiB7XG4gICAgaW5pdFdyYXBwZXI/OiAod3JhcHBlcjogV3JhcHBlcikgPT4gV3JhcHBlcjtcbiAgICBwcm9jZXNzRW50aXR5PzogKGVudGl0eTogRGF0YUVudGl0eSwgd3JhcHBlcjogV3JhcHBlcikgPT4gdm9pZDtcbiAgICBvblByb2Nlc3NGaW5pc2hlZD86ICh3cmFwcGVyOiBXcmFwcGVyKSA9PiB2b2lkO1xuICB9ID0ge30sXG4pIHtcbiAgY29uc3QgcG9zRW50aXRpZXMgPSB7fTtcbiAgY29uc3Qga2V5RW50aXRpZXMgPSB7fTtcbiAgbGV0IHdyYXBwZXIgPSB7XG4gICAgcG9zRW50aXRpZXMsXG4gICAga2V5RW50aXRpZXMsXG4gIH07XG5cbiAgaWYgKGluaXRXcmFwcGVyKSB7XG4gICAgd3JhcHBlciA9IGluaXRXcmFwcGVyKHdyYXBwZXIpIHx8IHdyYXBwZXI7XG4gIH1cblxuICB0cmF2ZXJzZURhdGFOb2RlcyhkYXRhTm9kZXMsIGl0ZW0gPT4ge1xuICAgIGNvbnN0IHsgbm9kZSwgaW5kZXgsIHBvcywga2V5LCBwYXJlbnRQb3MsIGxldmVsIH0gPSBpdGVtO1xuICAgIGNvbnN0IGVudGl0eTogRGF0YUVudGl0eSA9IHsgbm9kZSwgaW5kZXgsIGtleSwgcG9zLCBsZXZlbCB9O1xuXG4gICAgY29uc3QgbWVyZ2VkS2V5ID0gZ2V0S2V5KGtleSwgcG9zKTtcblxuICAgIHBvc0VudGl0aWVzW3Bvc10gPSBlbnRpdHk7XG4gICAga2V5RW50aXRpZXNbbWVyZ2VkS2V5XSA9IGVudGl0eTtcblxuICAgIC8vIEZpbGwgY2hpbGRyZW5cbiAgICBlbnRpdHkucGFyZW50ID0gcG9zRW50aXRpZXNbcGFyZW50UG9zXTtcbiAgICBpZiAoZW50aXR5LnBhcmVudCkge1xuICAgICAgZW50aXR5LnBhcmVudC5jaGlsZHJlbiA9IGVudGl0eS5wYXJlbnQuY2hpbGRyZW4gfHwgW107XG4gICAgICBlbnRpdHkucGFyZW50LmNoaWxkcmVuLnB1c2goZW50aXR5KTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzc0VudGl0eSkge1xuICAgICAgcHJvY2Vzc0VudGl0eShlbnRpdHksIHdyYXBwZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKG9uUHJvY2Vzc0ZpbmlzaGVkKSB7XG4gICAgb25Qcm9jZXNzRmluaXNoZWQod3JhcHBlcik7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmVlTm9kZVJlcXVpcmVkUHJvcHMge1xuICBleHBhbmRlZEtleXM6IEtleVtdO1xuICBzZWxlY3RlZEtleXM6IEtleVtdO1xuICBsb2FkZWRLZXlzOiBLZXlbXTtcbiAgbG9hZGluZ0tleXM6IEtleVtdO1xuICBjaGVja2VkS2V5czogS2V5W107XG4gIGhhbGZDaGVja2VkS2V5czogS2V5W107XG4gIGRyYWdPdmVyTm9kZUtleTogS2V5O1xuICBkcm9wUG9zaXRpb246IG51bWJlcjtcbiAga2V5RW50aXRpZXM6IFJlY29yZDxLZXksIERhdGFFbnRpdHk+O1xufVxuXG4vKipcbiAqIEdldCBUcmVlTm9kZSBwcm9wcyB3aXRoIFRyZWUgcHJvcHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmVlTm9kZVByb3BzKFxuICBrZXk6IEtleSxcbiAge1xuICAgIGV4cGFuZGVkS2V5cyxcbiAgICBzZWxlY3RlZEtleXMsXG4gICAgbG9hZGVkS2V5cyxcbiAgICBsb2FkaW5nS2V5cyxcbiAgICBjaGVja2VkS2V5cyxcbiAgICBoYWxmQ2hlY2tlZEtleXMsXG4gICAgZHJhZ092ZXJOb2RlS2V5LFxuICAgIGRyb3BQb3NpdGlvbixcbiAgICBrZXlFbnRpdGllcyxcbiAgfTogVHJlZU5vZGVSZXF1aXJlZFByb3BzLFxuKSB7XG4gIGNvbnN0IGVudGl0eSA9IGtleUVudGl0aWVzW2tleV07XG5cbiAgY29uc3QgdHJlZU5vZGVQcm9wcyA9IHtcbiAgICBldmVudEtleToga2V5LFxuICAgIGV4cGFuZGVkOiBleHBhbmRlZEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSxcbiAgICBzZWxlY3RlZDogc2VsZWN0ZWRLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEsXG4gICAgbG9hZGVkOiBsb2FkZWRLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEsXG4gICAgbG9hZGluZzogbG9hZGluZ0tleXMuaW5kZXhPZihrZXkpICE9PSAtMSxcbiAgICBjaGVja2VkOiBjaGVja2VkS2V5cy5pbmRleE9mKGtleSkgIT09IC0xLFxuICAgIGhhbGZDaGVja2VkOiBoYWxmQ2hlY2tlZEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSxcbiAgICBwb3M6IFN0cmluZyhlbnRpdHkgPyBlbnRpdHkucG9zIDogJycpLFxuXG4gICAgLy8gW0xlZ2FjeV0gRHJhZyBwcm9wc1xuICAgIGRyYWdPdmVyOiBkcmFnT3Zlck5vZGVLZXkgPT09IGtleSAmJiBkcm9wUG9zaXRpb24gPT09IDAsXG4gICAgZHJhZ092ZXJHYXBUb3A6IGRyYWdPdmVyTm9kZUtleSA9PT0ga2V5ICYmIGRyb3BQb3NpdGlvbiA9PT0gLTEsXG4gICAgZHJhZ092ZXJHYXBCb3R0b206IGRyYWdPdmVyTm9kZUtleSA9PT0ga2V5ICYmIGRyb3BQb3NpdGlvbiA9PT0gMSxcbiAgfTtcblxuICByZXR1cm4gdHJlZU5vZGVQcm9wcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnROb2RlUHJvcHNUb0V2ZW50RGF0YShcbiAgcHJvcHM6IFRyZWVOb2RlUHJvcHMsXG4pOiBFdmVudERhdGFOb2RlIHtcbiAgY29uc3Qge1xuICAgIGRhdGEsXG4gICAgZXhwYW5kZWQsXG4gICAgc2VsZWN0ZWQsXG4gICAgY2hlY2tlZCxcbiAgICBsb2FkZWQsXG4gICAgbG9hZGluZyxcbiAgICBoYWxmQ2hlY2tlZCxcbiAgICBkcmFnT3ZlcixcbiAgICBkcmFnT3ZlckdhcFRvcCxcbiAgICBkcmFnT3ZlckdhcEJvdHRvbSxcbiAgICBwb3MsXG4gICAgYWN0aXZlLFxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3QgZXZlbnREYXRhID0ge1xuICAgIC4uLmRhdGEsXG4gICAgZXhwYW5kZWQsXG4gICAgc2VsZWN0ZWQsXG4gICAgY2hlY2tlZCxcbiAgICBsb2FkZWQsXG4gICAgbG9hZGluZyxcbiAgICBoYWxmQ2hlY2tlZCxcbiAgICBkcmFnT3ZlcixcbiAgICBkcmFnT3ZlckdhcFRvcCxcbiAgICBkcmFnT3ZlckdhcEJvdHRvbSxcbiAgICBwb3MsXG4gICAgYWN0aXZlLFxuICB9O1xuXG4gIGlmICghKCdwcm9wcycgaW4gZXZlbnREYXRhKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudERhdGEsICdwcm9wcycsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnU2Vjb25kIHBhcmFtIHJldHVybiBmcm9tIGV2ZW50IGlzIG5vZGUgZGF0YSBpbnN0ZWFkIG9mIFRyZWVOb2RlIGluc3RhbmNlLiBQbGVhc2UgcmVhZCB2YWx1ZSBkaXJlY3RseSBpbnN0ZWFkIG9mIHJlYWRpbmcgZnJvbSBgcHJvcHNgLicsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZXZlbnREYXRhO1xufVxuIl0sInZlcnNpb24iOjN9